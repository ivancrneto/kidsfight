{"mappings":"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","sources":["<anon>","main.js","node_modules/@parcel/runtime-js/lib/runtime-9b5677149ce68126.js","node_modules/@parcel/runtime-js/lib/runtime-9e8f839b2074bf71.js","node_modules/@parcel/runtime-js/lib/runtime-336a052817fffa27.js","gameUtils.mjs"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n// Parcel image imports for Phaser asset loading\nvar $703cd0b7f1a80901$exports = {};\n$703cd0b7f1a80901$exports = import.meta.resolve(\"2ZnZY\");\n\n\nvar $29dc1bd428d227fa$exports = {};\n$29dc1bd428d227fa$exports = import.meta.resolve(\"foXlV\");\n\n\nvar $4d44d7ac7a91b6cd$exports = {};\n$4d44d7ac7a91b6cd$exports = import.meta.resolve(\"9MvWO\");\n\n\n// Pure game logic utilities for KidsFightScene\n// Layout update logic for scene objects\nfunction $4244f6a75d6df63d$export$2ba455e6ae328961(scene) {\n    const w = scene.scale.width;\n    const h = scene.scale.height;\n    // Background\n    if (scene.children && scene.children.list) {\n        const bg = scene.children.list.find((obj)=>obj.texture && obj.texture.key === 'scenario1');\n        if (bg) {\n            bg.setPosition(w / 2, h / 2);\n            bg.displayWidth = w;\n            bg.displayHeight = h;\n        }\n    }\n    // Platform\n    if (scene.children && scene.children.list) {\n        const platformRect = scene.children.list.find((obj)=>obj.type === 'Rectangle' && obj.fillColor === 0x8B5A2B);\n        if (platformRect) {\n            platformRect.setPosition(w / 2, 240);\n            platformRect.displayWidth = w;\n        }\n    }\n    // Camera and world bounds\n    if (scene.cameras && scene.cameras.main && scene.physics && scene.physics.world) {\n        scene.cameras.main.setBounds(0, 0, w, h);\n        scene.physics.world.setBounds(0, 0, w, h);\n    }\n    // Touch controls\n    if (typeof scene.updateControlPositions === 'function') scene.updateControlPositions();\n    // Health bars\n    if (scene.healthBar1 && scene.healthBar2 && scene.healthBar1Border && scene.healthBar2Border) {\n        // Bar width: 25% of screen width, height: 5% of height\n        const barWidth = w * 0.25;\n        const barHeight = h * 0.05;\n        const barY = h * 0.07;\n        const bar1X = w * 0.25;\n        const bar2X = w * 0.75;\n        scene.healthBar1Border.setPosition(bar1X, barY).setSize(barWidth + 4, barHeight + 4);\n        scene.healthBar2Border.setPosition(bar2X, barY).setSize(barWidth + 4, barHeight + 4);\n        scene.healthBar1.setPosition(bar1X, barY).setSize(barWidth, barHeight);\n        scene.healthBar2.setPosition(bar2X, barY).setSize(barWidth, barHeight);\n    }\n    // Special pips (3 per player) - match main.js create()\n    if (scene.specialPips1 && scene.specialPips2) {\n        const barY = h * 0.07;\n        const pipY = barY - h * 0.035; // slightly above health bar\n        const pipR = Math.max(10, h * 0.018); // match create()\n        // Player 1: left, spaced 30px apart at 800px width\n        for(let i = 0; i < 3; i++){\n            const pip1X = w * 0.25 - pipR * 3 + i * pipR * 3;\n            if (scene.specialPips1[i]) scene.specialPips1[i].setPosition(pip1X, pipY).setRadius(pipR);\n        }\n        // Player 2: right, spaced 30px apart at 800px width\n        for(let i = 0; i < 3; i++){\n            const pip2X = w * 0.75 - pipR * 3 + i * pipR * 3;\n            if (scene.specialPips2[i]) scene.specialPips2[i].setPosition(pip2X, pipY).setRadius(pipR);\n        }\n    }\n    // Special ready circles (big S) - match main.js create()\n    if (scene.specialReady1 && scene.specialReadyText1) {\n        const r = Math.max(20, h * 0.045);\n        const x = w * 0.25;\n        const y = h * 0.13;\n        scene.specialReady1.setPosition(x, y).setRadius(r);\n        scene.specialReadyText1.setPosition(x, y);\n    }\n    if (scene.specialReady2 && scene.specialReadyText2) {\n        const r = Math.max(20, h * 0.045);\n        const x = w * 0.75;\n        const y = h * 0.13;\n        scene.specialReady2.setPosition(x, y).setRadius(r);\n        scene.specialReadyText2.setPosition(x, y);\n    }\n    // Timer text\n    if (scene.timerText) {\n        // Font size: min 32px, but scale up for large screens (e.g. 4vw)\n        const fontSize = Math.max(32, Math.round(w * 0.045));\n        scene.timerText.setFontSize(fontSize + 'px');\n        scene.timerText.setPosition(w / 2, h * 0.11);\n    }\n}\n// CSS application logic for game canvas and parent\nfunction $4244f6a75d6df63d$export$36c7bbefcce976d2() {\n    const canvas = document.querySelector('canvas');\n    const parent = document.getElementById('game-container');\n    if (canvas) {\n        canvas.style.position = 'fixed';\n        canvas.style.left = 'env(safe-area-inset-left, 0px)';\n        canvas.style.top = 'env(safe-area-inset-top, 0px)';\n        canvas.style.width = 'calc(100vw - env(safe-area-inset-left, 0px) - env(safe-area-inset-right, 0px))';\n        canvas.style.height = 'calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px))';\n        canvas.style.maxWidth = '100vw';\n        canvas.style.maxHeight = '100vh';\n        canvas.style.objectFit = 'contain';\n        canvas.style.background = '#222';\n    }\n    if (parent) {\n        parent.style.position = 'fixed';\n        parent.style.left = 'env(safe-area-inset-left, 0px)';\n        parent.style.top = 'env(safe-area-inset-top, 0px)';\n        parent.style.width = '100vw';\n        parent.style.height = '100vh';\n        parent.style.background = '#222';\n        parent.style.overflow = 'hidden';\n    }\n}\n// tryAttack logic (simplified for testability)\nfunction $4244f6a75d6df63d$export$d918436b04969c89(scene, playerIdx, attacker, defender, now, special) {\n    // Robustly determine defenderIdx\n    let defenderIdx = undefined;\n    if (defender === scene.player1) defenderIdx = 0;\n    else if (defender === scene.player2) defenderIdx = 1;\n    else {\n        console.error('[TRYATTACK] Could not determine defenderIdx!', defender, scene.player1, scene.player2);\n        return;\n    }\n    console.log('[TRYATTACK] defenderIdx:', defenderIdx, 'playerHealth before:', scene.playerHealth[defenderIdx]);\n    if (!attacker || !defender) return;\n    const ATTACK_RANGE = 180;\n    const ATTACK_COOLDOWN = 500;\n    if (!scene.lastAttackTime) scene.lastAttackTime = [\n        0,\n        0\n    ];\n    if (!scene.attackCount) scene.attackCount = [\n        0,\n        0\n    ];\n    if (now - scene.lastAttackTime[playerIdx] < ATTACK_COOLDOWN) // console.log('[DEBUG] tryAttack: Attack on cooldown for player', playerIdx);\n    return;\n    if (Math.abs(attacker.x - defender.x) > ATTACK_RANGE) // console.log('[DEBUG] tryAttack: Out of range. Attacker x:', attacker.x, 'Defender x:', defender.x);\n    return;\n    scene.lastAttackTime[playerIdx] = now;\n    scene.attackCount[playerIdx]++;\n    scene.playerHealth[defenderIdx] = (typeof scene.playerHealth[defenderIdx] === 'number' ? scene.playerHealth[defenderIdx] : 100) - (special ? 30 : 10);\n    console.log('[TRYATTACK] playerHealth after:', scene.playerHealth[defenderIdx]);\n    if (scene.cameras && scene.cameras.main && typeof scene.cameras.main.shake === 'function') scene.cameras.main.shake(special ? 250 : 100, special ? 0.03 : 0.01);\n}\n\n\n// Dynamically set game size based on viewport, accounting for mobile browser UI\nconst $efd3ba4ec2608b1d$var$GAME_WIDTH = window.innerWidth;\nconst $efd3ba4ec2608b1d$var$GAME_HEIGHT = window.innerHeight;\nconst $efd3ba4ec2608b1d$var$PLAYER_SIZE = 192;\nconst $efd3ba4ec2608b1d$var$PLAYER_SPEED = 200;\nconst $efd3ba4ec2608b1d$var$JUMP_VELOCITY = -400;\nconst $efd3ba4ec2608b1d$var$GRAVITY = 900;\nconst $efd3ba4ec2608b1d$var$ATTACK_RANGE = 100;\nconst $efd3ba4ec2608b1d$var$ATTACK_COOLDOWN = 500;\nconst $efd3ba4ec2608b1d$var$MAX_HEALTH = 100;\nconst $efd3ba4ec2608b1d$var$ROUND_TIME = 60;\n// import PlayerSelectScene from './player_select_scene.js';\nclass $efd3ba4ec2608b1d$var$KidsFightScene extends Phaser.Scene {\n    // --- EFFECTS: Special Effect Helper (Phaser 3.60+ workaround) ---\n    showSpecialEffect(x, y, count = 30) {\n        if (!this.specialEffect) return;\n        this.specialEffect.clear();\n        this.specialEffect.setVisible(true);\n        this.specialEffect.setAlpha(1);\n        this.specialEffect.setScale(1);\n        this.specialEffect.lineStyle(8, 0x00eaff, 0.7);\n        this.specialEffect.strokeCircle(x, y, 20);\n        this.tweens.add({\n            targets: this.specialEffect,\n            alpha: 0,\n            scaleX: 2,\n            scaleY: 2,\n            duration: 350,\n            onComplete: ()=>{\n                this.specialEffect.clear();\n                this.specialEffect.setVisible(false);\n                this.specialEffect.setAlpha(1);\n                this.specialEffect.setScale(1);\n            }\n        });\n    }\n    constructor(){\n        super('KidsFightScene');\n        this.lastAttackTime = [\n            0,\n            0\n        ];\n        this.attackCount = [\n            0,\n            0\n        ]; // Counts normal attacks landed by each player\n        this.lungeTimer = [\n            0,\n            0\n        ]; // Initialize lunge timers for both players\n        this.timeLeft = 60;\n        this.player1State = 'idle';\n        // console.log('[DEBUG] player1State set to:', this.player1State); // 'idle', 'down', 'attack', 'special'\n        this.player2State = 'idle';\n    // // console.log('[constructor] timeLeft:', this.timeLeft, 'ROUND_TIME:', typeof ROUND_TIME !== 'undefined' ? ROUND_TIME : 'undefined');\n    }\n    init(data) {\n        this.selected = data || {\n            p1: 0,\n            p2: 1\n        };\n    }\n    preload() {\n        // Debug: Print imported image URLs and types\n        // console.log('scenario1Img', scenario1Img, typeof scenario1Img);\n        // console.log('player1RawImg', player1RawImg, typeof player1RawImg);\n        // console.log('player2RawImg', player2RawImg, typeof player2RawImg);\n        // Load player sprite sheets (256x256)\n        this.load.image('player1_raw', (0, (/*@__PURE__*/$parcel$interopDefault($29dc1bd428d227fa$exports))));\n        this.load.image('player2_raw', (0, (/*@__PURE__*/$parcel$interopDefault($4d44d7ac7a91b6cd$exports))));\n        // Load scenario background\n        this.load.image('scenario1', (0, (/*@__PURE__*/$parcel$interopDefault($703cd0b7f1a80901$exports))));\n    // Load particle spritesheet for effects\n    //this.load.atlas('flares', 'flares.png', 'flares.json');\n    }\n    create() {\n        // --- RESET ALL GAME STATE ON RESTART ---\n        this.gameOver = false;\n        this.player1State = 'idle';\n        this.player2State = 'idle';\n        this.lastAttackTime = [\n            0,\n            0\n        ];\n        this.attackCount = [\n            0,\n            0\n        ];\n        this.lungeTimer = [\n            0,\n            0\n        ];\n        this.timeLeft = 60;\n        this.playerHealth = [\n            $efd3ba4ec2608b1d$var$MAX_HEALTH,\n            $efd3ba4ec2608b1d$var$MAX_HEALTH\n        ];\n        // console.log('[DEBUG] create() this:', this, 'scene key:', this.sys && this.sys.settings && this.sys.settings.key);\n        // --- CREATE CUSTOM SPRITESHEETS FIRST ---\n        // Player 1\n        if (!this.textures.exists('player1')) {\n            const frameWidths = [\n                300,\n                300,\n                400,\n                460,\n                500,\n                440,\n                440,\n                440\n            ];\n            const frameHeight = 512;\n            const player1Texture = this.textures.get('player1_raw').getSourceImage();\n            this.textures.addSpriteSheet('player1', player1Texture, {\n                frameWidth: 430,\n                frameHeight: frameHeight,\n                startFrame: 0,\n                endFrame: 6\n            });\n            const tex = this.textures.get('player1');\n            tex.frames = {\n                __BASE: tex.frames['__BASE']\n            };\n            let x = 0;\n            for(let i = 0; i < frameWidths.length; i++){\n                tex.add(i, 0, x, 0, frameWidths[i], frameHeight);\n                x += frameWidths[i];\n            }\n        }\n        // Player 2\n        if (!this.textures.exists('player2')) {\n            const frameWidths2 = [\n                300,\n                300,\n                400,\n                460,\n                500,\n                400,\n                400,\n                400\n            ];\n            const frameHeight2 = 512;\n            const player2Texture = this.textures.get('player2_raw').getSourceImage();\n            this.textures.addSpriteSheet('player2', player2Texture, {\n                frameWidth: 400,\n                frameHeight: frameHeight2,\n                startFrame: 0,\n                endFrame: frameWidths2.length - 1\n            });\n            const tex2 = this.textures.get('player2');\n            tex2.frames = {\n                __BASE: tex2.frames['__BASE']\n            };\n            let x2 = 0;\n            for(let i = 0; i < frameWidths2.length; i++){\n                tex2.add(i, 0, x2, 0, frameWidths2[i], frameHeight2);\n                x2 += frameWidths2[i];\n            }\n        }\n        // Add background image\n        const bg = this.add.image($efd3ba4ec2608b1d$var$GAME_WIDTH / 2, $efd3ba4ec2608b1d$var$GAME_HEIGHT / 2, 'scenario1').setOrigin(0.5, 0.5);\n        bg.displayWidth = $efd3ba4ec2608b1d$var$GAME_WIDTH;\n        bg.displayHeight = $efd3ba4ec2608b1d$var$GAME_HEIGHT;\n        // Ensure world and camera bounds match the visible area (for mobile/responsive)\n        const cam = this.cameras.main;\n        if (this.isTouch) {\n            // Decrease bounds by 10% on each side for mobile\n            const padX = cam.width * 0.1;\n            const padY = cam.height * 0.05;\n            this.physics.world.setBounds(padX, padY, cam.width - 2 * padX, cam.height - 2 * padY);\n            this.cameras.main.setBounds(padX, padY, cam.width - 2 * padX, cam.height - 2 * padY);\n        } else {\n            this.physics.world.setBounds(0, 0, cam.width, cam.height);\n            this.cameras.main.setBounds(0, 0, cam.width, cam.height);\n        }\n        // --- TOUCH CONTROLS ---\n        this.touchControls = {\n            p1: {},\n            p2: {}\n        };\n        // Robust touch detection (works on iOS and all browsers)\n        const debugAlwaysShowTouch = false; // set to true to force show for debugging\n        this.isTouch = debugAlwaysShowTouch || typeof window !== 'undefined' && (navigator.maxTouchPoints && navigator.maxTouchPoints > 0 || 'ontouchstart' in window);\n        if (this.isTouch) {\n            const cam = this.cameras.main;\n            const w = cam.width;\n            const h = cam.height;\n            // Player 1 (left side) - relative positions\n            this.touchControls.p1.left = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p1.right = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p1.jump = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p1.down = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p1.attack = this.add.circle(0, 0, 30, 0xff4444, 0.8).setInteractive().setDepth(9999);\n            this.touchControls.p1.special = this.add.circle(0, 0, 30, 0xffd700, 0.8).setInteractive().setDepth(9999);\n            // Player 2 (right side) - relative positions\n            this.touchControls.p2.left = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p2.right = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p2.jump = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p2.down = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n            this.touchControls.p2.attack = this.add.circle(0, 0, 30, 0x44aaff, 0.8).setInteractive().setDepth(9999);\n            this.touchControls.p2.special = this.add.circle(0, 0, 30, 0xffd700, 0.8).setInteractive().setDepth(9999);\n            // Touch flags\n            this.touchFlags = {\n                p1: {\n                    left: false,\n                    right: false,\n                    jump: false,\n                    down: false,\n                    attack: false,\n                    special: false\n                },\n                p2: {\n                    left: false,\n                    right: false,\n                    jump: false,\n                    down: false,\n                    attack: false,\n                    special: false\n                }\n            };\n            // Setup touch events for all buttons\n            const setupBtn = (btn, flagObj, flag)=>{\n                btn.on('pointerdown', ()=>{\n                    flagObj[flag] = true;\n                });\n                btn.on('pointerup', ()=>{\n                    flagObj[flag] = false;\n                });\n                btn.on('pointerout', ()=>{\n                    flagObj[flag] = false;\n                });\n                btn.on('pointerupoutside', ()=>{\n                    flagObj[flag] = false;\n                });\n            };\n            Object.entries(this.touchControls.p1).forEach(([k, btn])=>setupBtn(btn, this.touchFlags.p1, k));\n            Object.entries(this.touchControls.p2).forEach(([k, btn])=>setupBtn(btn, this.touchFlags.p2, k));\n            // Add icons/labels (also relative)\n            this.touchLabels = [];\n            this.touchLabels.push(this.add.text(0, 0, '<', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, '>', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, '^', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'v', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'A', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'S', {\n                fontSize: '24px',\n                color: '#222'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, '<', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, '>', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, '^', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'v', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'A', {\n                fontSize: '24px',\n                color: '#fff'\n            }).setDepth(10000));\n            this.touchLabels.push(this.add.text(0, 0, 'S', {\n                fontSize: '24px',\n                color: '#222'\n            }).setDepth(10000));\n            // Immediately position all touch labels\n            this.updateControlPositions();\n        }\n        // --- EFFECTS ---\n        // Hit flash effect for attacks\n        this.hitFlash = this.add.graphics({\n            x: 0,\n            y: 0\n        }).setDepth(999);\n        this.hitFlash.setVisible(false);\n        // Particle system and emitter for special attacks\n        // Simple custom effect for special attacks (Phaser 3.60+ workaround)\n        this.specialEffect = this.add.graphics({\n            x: 0,\n            y: 0\n        }).setDepth(998);\n        this.specialEffect.setVisible(false);\n        // --- EFFECTS ---\n        // --- PLAYER SPAWN LOGIC (moved from orphaned code) ---\n        const playerSprites = [\n            'player1',\n            'player2'\n        ];\n        // Responsive player scale based on height (target ~38% of screen height)\n        const scale = $efd3ba4ec2608b1d$var$GAME_HEIGHT * 0.38 / 512;\n        const frameHeight = 512;\n        const player1FrameWidths = [\n            300,\n            300,\n            430,\n            580,\n            580,\n            440,\n            440,\n            440\n        ];\n        // Align player feet to the ground (bottom of the screen)\n        const frameWidth = player1FrameWidths[0];\n        const bodyWidth = frameWidth * scale;\n        const bodyHeight = frameHeight * scale;\n        // player.y is the center, so set: playerY = GAME_HEIGHT - (this.textures.get('player1').getSourceImage().height * scale) / 2;\n        // But we can use the actual sprite height after creation for precision\n        // Responsive platform position and height\n        const PLATFORM_Y = $efd3ba4ec2608b1d$var$GAME_HEIGHT * 0.7; // 70% down the screen (lower for desktop)\n        const PLATFORM_HEIGHT = $efd3ba4ec2608b1d$var$GAME_HEIGHT * 0.045; // 4.5% of screen height\n        // Add background image\n        bg.displayWidth = $efd3ba4ec2608b1d$var$GAME_WIDTH;\n        bg.displayHeight = $efd3ba4ec2608b1d$var$GAME_HEIGHT;\n        // Draw the platform rectangle above the background\n        const platformRect = this.add.rectangle($efd3ba4ec2608b1d$var$GAME_WIDTH / 2, PLATFORM_Y + PLATFORM_HEIGHT / 2, $efd3ba4ec2608b1d$var$GAME_WIDTH, PLATFORM_HEIGHT, 0x8B5A2B).setDepth(2).setVisible(false);\n        // Add static physics body for the platform\n        const platform = this.physics.add.staticGroup();\n        platform.create($efd3ba4ec2608b1d$var$GAME_WIDTH / 2, PLATFORM_Y + PLATFORM_HEIGHT / 2, null).setDisplaySize($efd3ba4ec2608b1d$var$GAME_WIDTH, PLATFORM_HEIGHT).setVisible(false).refreshBody();\n        // --- DEFENSIVE: Ensure valid selected and sprite keys ---\n        const playerSpritesSafe = [\n            'player1',\n            'player2'\n        ];\n        const selectedSafe = this.selected && typeof this.selected.p1 === 'number' && typeof this.selected.p2 === 'number' ? this.selected : {\n            p1: 0,\n            p2: 1\n        };\n        const p1Key = playerSpritesSafe[selectedSafe.p1] || 'player1';\n        const p2Key = playerSpritesSafe[selectedSafe.p2] || 'player2';\n        const PLAYER_PLATFORM_OFFSET = 20;\n        // Responsive player spawn positions\n        const p1X = $efd3ba4ec2608b1d$var$GAME_WIDTH * 0.25;\n        const p2X = $efd3ba4ec2608b1d$var$GAME_WIDTH * 0.75;\n        const playerY = PLATFORM_Y + PLAYER_PLATFORM_OFFSET;\n        this.player1 = this.physics.add.sprite(p1X, playerY, p1Key, 0);\n        this.player1.setScale(scale);\n        this.player1.setOrigin(0.5, 1); // bottom center\n        this.player1.body.setSize(this.player1.displayWidth, this.player1.displayHeight);\n        this.player1.body.setOffset(0, 0);\n        // Enable collision with platform\n        this.physics.add.collider(this.player1, platform);\n        this.player1.setCollideWorldBounds(true);\n        this.player1.setBounce(0.1);\n        this.player1.facing = 1;\n        this.player2 = this.physics.add.sprite(p2X, playerY, p2Key, 0);\n        this.player2.setScale(scale);\n        this.player2.setOrigin(0.5, 1); // bottom center\n        this.player2.body.setSize(this.player2.displayWidth, this.player2.displayHeight);\n        this.player2.body.setOffset(0, 0);\n        // Enable collision with platform\n        this.physics.add.collider(this.player2, platform);\n        this.player2.setCollideWorldBounds(true);\n        this.player2.setBounce(0.1);\n        this.player2.facing = -1;\n        this.player2.setFlipX(true); // Invert horizontally\n        // Player 1 Animations (custom frames)\n        if (!this.anims.exists('p1_idle')) this.anims.create({\n            key: 'p1_idle',\n            frames: [\n                {\n                    key: 'player1',\n                    frame: 0\n                }\n            ],\n            frameRate: 1,\n            repeat: -1\n        });\n        if (!this.anims.exists('p1_walk')) this.anims.create({\n            key: 'p1_walk',\n            frames: [\n                {\n                    key: 'player1',\n                    frame: 1\n                },\n                {\n                    key: 'player1',\n                    frame: 2\n                }\n            ],\n            frameRate: 6,\n            repeat: -1\n        });\n        if (!this.anims.exists('p1_attack')) this.anims.create({\n            key: 'p1_attack',\n            frames: [\n                {\n                    key: 'player1',\n                    frame: 4\n                }\n            ],\n            frameRate: 1,\n            repeat: 0,\n            duration: 200 // Show hit frame for 200ms\n        });\n        if (!this.anims.exists('p1_special')) this.anims.create({\n            key: 'p1_special',\n            frames: [\n                {\n                    key: 'player1',\n                    frame: 6\n                }\n            ],\n            frameRate: 1,\n            repeat: 0,\n            duration: 900 // Show special frame for 900ms\n        });\n        // Down/crouch animations\n        if (!this.anims.exists('p1_down')) this.anims.create({\n            key: 'p1_down',\n            frames: [\n                {\n                    key: 'player1',\n                    frame: 5\n                }\n            ],\n            frameRate: 1,\n            repeat: -1\n        });\n        // Animations\n        if (!this.anims.exists('p2_idle')) this.anims.create({\n            key: 'p2_idle',\n            frames: [\n                {\n                    key: 'player2',\n                    frame: 0\n                }\n            ],\n            frameRate: 1,\n            repeat: -1\n        });\n        if (!this.anims.exists('p2_walk')) this.anims.create({\n            key: 'p2_walk',\n            frames: [\n                {\n                    key: 'player2',\n                    frame: 0\n                },\n                {\n                    key: 'player2',\n                    frame: 1\n                }\n            ],\n            frameRate: 6,\n            repeat: -1\n        });\n        if (!this.anims.exists('p2_attack')) this.anims.create({\n            key: 'p2_attack',\n            frames: [\n                {\n                    key: 'player2',\n                    frame: 4\n                }\n            ],\n            frameRate: 1,\n            repeat: 0,\n            duration: 200 // Show hit frame for 200ms\n        });\n        if (!this.anims.exists('p2_down')) this.anims.create({\n            key: 'p2_down',\n            frames: [\n                {\n                    key: 'player2',\n                    frame: 5\n                }\n            ],\n            frameRate: 1,\n            repeat: -1\n        });\n        if (!this.anims.exists('p2_special')) this.anims.create({\n            key: 'p2_special',\n            frames: [\n                {\n                    key: 'player2',\n                    frame: 6\n                }\n            ],\n            frameRate: 1,\n            repeat: 0,\n            duration: 900 // Show special frame for 900ms\n        });\n        this.player1.play('p1_idle');\n        this.player1.angle = 0;\n        this.player2.angle = 0;\n        // Reset loser y offset (in case of rematch)\n        this.playerY = playerY; // Store globally for use in endGame\n        if (!this.gameOver) this.player2.play('p2_idle');\n        // Store original Y for laying down math\n        this.player1._originalY = this.player1.y;\n        this.player2._originalY = this.player2.y;\n        // Animation complete: return to idle after attack\n        // (Replaced by manual timer for attack/special)\n        // this.player1.on('animationcomplete', ...)\n        // this.player2.on('animationcomplete', ...)\n        // Collisions\n        this.physics.add.collider(this.player1, this.floatPlatform);\n        this.physics.add.collider(this.player2, this.floatPlatform);\n        // Controls\n        this.cursors = this.input.keyboard.createCursorKeys();\n        this.keys = this.input.keyboard.addKeys({\n            a: 'A',\n            d: 'D',\n            w: 'W',\n            v: 'V',\n            b: 'B',\n            n: 'N',\n            s: 'S',\n            k: 'K',\n            l: 'L',\n            semicolon: 'SEMICOLON'\n        });\n        // Defensive: ensure all keys exist even if not mapped\n        const keyList = [\n            'a',\n            'd',\n            'w',\n            'v',\n            'b',\n            'n',\n            's',\n            'k',\n            'l',\n            'semicolon'\n        ];\n        for (const k of keyList)if (!this.keys[k]) this.keys[k] = {\n            isDown: false\n        };\n        // Debug: log at end of create()\n        // console.log('[DEBUG] create() called, this.keys:', this.keys);\n        // Global keydown debug (disable for touch)\n        if (!this.isTouch) window.addEventListener('keydown', function(e) {\n        // console.log('[GLOBAL] Key pressed:', e.key, 'code:', e.code);\n        });\n        // Health bars\n        this.healthBar1Border = this.add.rectangle(200, 30, 204, 24, 0xffffff).setOrigin(0.5);\n        this.healthBar2Border = this.add.rectangle(600, 30, 204, 24, 0xffffff).setOrigin(0.5);\n        this.healthBar1Border.setStrokeStyle(2, 0x000000);\n        this.healthBar2Border.setStrokeStyle(2, 0x000000);\n        this.healthBar1 = this.add.rectangle(200, 30, 200, 20, 0xff4444);\n        this.healthBar2 = this.add.rectangle(600, 30, 200, 20, 0x44aaff);\n        this.healthBar1.setOrigin(0.5);\n        this.healthBar2.setOrigin(0.5);\n        this.children.bringToTop(this.healthBar1);\n        this.children.bringToTop(this.healthBar2);\n        // --- SPECIAL HIT CIRCLES (PIPS) ---\n        // Player 1 special pips (left, above health bar)\n        this.specialPips1 = [];\n        for(let i = 0; i < 3; i++){\n            const pip = this.add.circle(140 + i * 30, 16, 10, 0x888888, 0.8).setStrokeStyle(2, 0x000).setDepth(10);\n            pip.setVisible(true);\n            this.specialPips1.push(pip);\n        }\n        // Player 2 special pips (right, above health bar)\n        this.specialPips2 = [];\n        for(let i = 0; i < 3; i++){\n            const pip = this.add.circle(540 + i * 30, 16, 10, 0x888888, 0.8).setStrokeStyle(2, 0x000).setDepth(10);\n            pip.setVisible(true);\n            this.specialPips2.push(pip);\n        }\n        // Ensure all pips are reset to gray and visible\n        this.specialPips1.forEach((pip)=>pip.setFillStyle(0x888888).setVisible(true));\n        this.specialPips2.forEach((pip)=>pip.setFillStyle(0x888888).setVisible(true));\n        // Hide special ready circles\n        if (this.specialReady1) this.specialReady1.setVisible(false);\n        if (this.specialReadyText1) this.specialReadyText1.setVisible(false);\n        if (this.specialReady2) this.specialReady2.setVisible(false);\n        if (this.specialReadyText2) this.specialReadyText2.setVisible(false);\n        // --- SPECIAL READY CIRCLE (BIG S) ---\n        // Player 1\n        this.specialReady1 = this.add.circle(200, 60, 22, 0xffd700, 0.93).setStrokeStyle(3, 0x000).setDepth(15).setVisible(false);\n        this.specialReadyText1 = this.add.text(200, 60, 'S', {\n            fontSize: '26px',\n            color: '#000',\n            fontFamily: 'monospace',\n            fontStyle: 'bold'\n        }).setOrigin(0.5).setDepth(16).setVisible(false);\n        // Player 2\n        this.specialReady2 = this.add.circle(600, 60, 22, 0xffd700, 0.93).setStrokeStyle(3, 0x000).setDepth(15).setVisible(false);\n        this.specialReadyText2 = this.add.text(600, 60, 'S', {\n            fontSize: '26px',\n            color: '#000',\n            fontFamily: 'monospace',\n            fontStyle: 'bold'\n        }).setOrigin(0.5).setDepth(16).setVisible(false);\n        // Timer text display\n        this.timerText = this.add.text($efd3ba4ec2608b1d$var$GAME_WIDTH / 2, 50, Math.ceil(this.timeLeft), {\n            fontSize: '32px',\n            color: '#fff',\n            fontFamily: 'monospace',\n            align: 'center',\n            stroke: '#000',\n            strokeThickness: 4\n        }).setOrigin(0.5);\n        // --- FORCE RESIZE after scene (re)start ---\n        if (typeof $efd3ba4ec2608b1d$var$resizeGame === 'function') $efd3ba4ec2608b1d$var$resizeGame(this.game);\n        // Update all scene layout to match new size\n        this.updateSceneLayout();\n        // Listen for Phaser's resize event and re-apply CSS AND update layout\n        this.scale.on('resize', ()=>{\n            if (typeof (0, $4244f6a75d6df63d$export$36c7bbefcce976d2) === 'function') (0, $4244f6a75d6df63d$export$36c7bbefcce976d2)();\n            if (typeof this.updateSceneLayout === 'function') this.updateSceneLayout();\n        });\n    }\n    update(time, delta) {\n        if (this.gameOver) return;\n        // --- SPECIAL PIPS UPDATE LOGIC ---\n        // Helper: update special pips and indicators for a player\n        const updateSpecialPips = (playerIdx)=>{\n            const attackCount = this.attackCount?.[playerIdx] || 0;\n            const pips = playerIdx === 0 ? this.specialPips1 : this.specialPips2;\n            const specialReady = playerIdx === 0 ? this.specialReady1 : this.specialReady2;\n            const specialReadyText = playerIdx === 0 ? this.specialReadyText1 : this.specialReadyText2;\n            // Show yellow for each attack landed, up to 3, but hide all after 3\n            if (attackCount >= 3) {\n                // Hide all pips\n                for(let i = 0; i < 3; i++)if (pips[i]) pips[i].setVisible(false);\n                if (specialReady) specialReady.setVisible(true);\n                if (specialReadyText) specialReadyText.setVisible(true);\n            } else {\n                for(let i = 0; i < 3; i++)if (pips[i]) pips[i].setFillStyle(i < attackCount ? 0xffd700 : 0x888888).setVisible(true);\n                if (specialReady) specialReady.setVisible(false);\n                if (specialReadyText) specialReadyText.setVisible(false);\n            }\n        };\n        // Call for both players\n        updateSpecialPips(0);\n        updateSpecialPips(1);\n        // console.log('[DEBUG] update() this:', this, 'scene key:', this.sys && this.sys.settings && this.sys.settings.key);\n        if (!this.keys || !this.keys.v) // console.log('[DEBUG] this.keys or this.keys.v is undefined in update()');\n        return;\n        // Debug: confirm update is running\n        // console.log('[DEBUG] Update running');\n        // --- TOUCH CONTROLS: map to key states ---\n        // --- TOUCH CONTROLS: custom justPressed for attack/special ---\n        if (this.isTouch && this.touchFlags) {\n            // Setup justPressed logic for attack/special\n            if (!this._touchWasDownP1A && this.touchFlags.p1.attack) this._touchJustPressedP1A = true;\n            this._touchWasDownP1A = this.touchFlags.p1.attack;\n            if (!this._touchWasDownP1S && this.touchFlags.p1.special) this._touchJustPressedP1S = true;\n            this._touchWasDownP1S = this.touchFlags.p1.special;\n            if (!this._touchWasDownP2A && this.touchFlags.p2.attack) this._touchJustPressedP2A = true;\n            this._touchWasDownP2A = this.touchFlags.p2.attack;\n            if (!this._touchWasDownP2S && this.touchFlags.p2.special) this._touchJustPressedP2S = true;\n            this._touchWasDownP2S = this.touchFlags.p2.special;\n            // Map movement keys from touch to key states\n            this.keys.a.isDown = this.touchFlags.p1.left;\n            this.keys.d.isDown = this.touchFlags.p1.right;\n            this.keys.w.isDown = this.touchFlags.p1.jump;\n            this.keys.s.isDown = this.touchFlags.p1.down;\n            this.cursors.left.isDown = this.touchFlags.p2.left;\n            this.cursors.right.isDown = this.touchFlags.p2.right;\n            this.cursors.up.isDown = this.touchFlags.p2.jump;\n            this.cursors.down.isDown = this.touchFlags.p2.down;\n        }\n        // On desktop, do not overwrite keyboard input\n        // Timer logic (regressive)\n        if (!this.gameOver) {\n            if (typeof this.lastTimerUpdate !== 'number' || isNaN(this.lastTimerUpdate)) this.lastTimerUpdate = time;\n            if (typeof this.timeLeft !== 'number' || isNaN(this.timeLeft)) this.timeLeft = $efd3ba4ec2608b1d$var$ROUND_TIME;\n            const timerElapsed = Math.floor((time - this.lastTimerUpdate) / 1000);\n            if (timerElapsed > 0) {\n                this.timeLeft = Math.max(0, this.timeLeft - timerElapsed);\n                this.lastTimerUpdate += timerElapsed * 1000;\n            }\n        }\n        // Update timer display\n        if (this.timerText) this.timerText.setText(Math.ceil(this.timeLeft));\n        // Invert frames if players cross each other\n        if (this.player1 && this.player2) {\n            if (this.player1.x > this.player2.x) {\n                this.player1.setFlipX(true); // Face left\n                this.player2.setFlipX(false); // Face right\n            } else {\n                this.player1.setFlipX(false); // Face right\n                this.player2.setFlipX(true); // Face left\n            }\n        }\n        // Check win/lose by health\n        // Health-based win detection\n        if (!this.gameOver && this.player1 && this.player2) {\n            if (this.playerHealth[0] <= 0) {\n                this.endGame('Davi R Venceu!');\n                return;\n            } else if (this.playerHealth[1] <= 0) {\n                this.endGame('Bento Venceu!');\n                return;\n            }\n        }\n        if (this.timeLeft === 0) {\n            if (this.playerHealth[0] > this.playerHealth[1]) this.endGame('Bento Venceu!');\n            else if (this.playerHealth[1] > this.playerHealth[0]) this.endGame('Davi R Venceu!');\n            else this.endGame('Empate!');\n            return;\n        }\n        // Timer logic (regressive)\n        if (this.timeLeft <= 0 && !this.gameOver) {\n            this.endGame(\"Tempo Esgotado! Empate!\");\n            return;\n        }\n        // Player 1 movement\n        let p1Moving = false;\n        if (this.player1 && this.player1.body) {\n            const p1 = this.player1.body;\n            if (this.lungeTimer[0] > 0) this.lungeTimer[0] -= delta;\n            else {\n                p1.setVelocityX(0);\n                if (this.keys.a.isDown) {\n                    p1.setVelocityX(-$efd3ba4ec2608b1d$var$PLAYER_SPEED);\n                    p1Moving = true;\n                }\n                if (this.keys.d.isDown) {\n                    p1.setVelocityX($efd3ba4ec2608b1d$var$PLAYER_SPEED);\n                    p1Moving = true;\n                }\n                if (this.keys.w.isDown && p1.onFloor()) p1.setVelocityY($efd3ba4ec2608b1d$var$JUMP_VELOCITY);\n            }\n            // Player 1 walk animation\n            if (this.player1State === 'idle' && p1Moving && p1.onFloor() && !this.gameOver) {\n                if (this.player1.anims.currentAnim?.key !== 'p1_walk') this.player1.play('p1_walk', true);\n            } else if (this.player1State === 'idle' && this.player1.anims.currentAnim?.key === 'p1_walk' && !this.gameOver) {\n                if (!this.gameOver) this.player1.play('p1_idle', true);\n            }\n        }\n        // Player 2 movement\n        let p2Moving = false;\n        if (this.player2 && this.player2.body) {\n            const p2 = this.player2.body;\n            if (this.lungeTimer[1] > 0) this.lungeTimer[1] -= delta;\n            else {\n                p2.setVelocityX(0);\n                if (this.cursors.left.isDown) {\n                    p2.setVelocityX(-$efd3ba4ec2608b1d$var$PLAYER_SPEED);\n                    p2Moving = true;\n                }\n                if (this.cursors.right.isDown) {\n                    p2.setVelocityX($efd3ba4ec2608b1d$var$PLAYER_SPEED);\n                    p2Moving = true;\n                }\n                if (this.cursors.up.isDown && p2.onFloor()) p2.setVelocityY($efd3ba4ec2608b1d$var$JUMP_VELOCITY);\n            }\n            // Player 2 walk animation\n            if (this.player2State === 'idle' && p2Moving && p2.onFloor() && !this.gameOver) {\n                if (this.player2.anims.currentAnim?.key !== 'p2_walk') this.player2.play('p2_walk', true);\n            } else if (this.player2State === 'idle' && this.player2.anims.currentAnim?.key === 'p2_walk' && !this.gameOver) {\n                if (!this.gameOver) this.player2.play('p2_idle', true);\n            }\n        }\n        // Player 1 crouch (S or N key)\n        if (!this.gameOver) {\n            if (this.player1State === 'attack' || this.player1State === 'special') ;\n            else if (this.keys && (this.keys.n && this.keys.n.isDown || this.keys.s && this.keys.s.isDown)) {\n                if (this.player1State !== 'down') {\n                    this.player1.play('p1_down', true);\n                    this.player1State = 'down';\n                }\n            } else if (this.player1State !== 'idle') {\n                // Only play idle if game is not over\n                if (!this.gameOver) this.player1.play('p1_idle', true);\n                this.player1State = 'idle';\n            // console.log('[DEBUG] player1State set to:', this.player1State);\n            }\n        }\n        // Player 2 crouch (Down arrow or ; key)\n        if (!this.gameOver) {\n            if (this.player2State === 'attack' || this.player2State === 'special') ;\n            else if (this.cursors && this.cursors.down && this.cursors.down.isDown || this.keys && this.keys.semicolon && this.keys.semicolon.isDown) {\n                if (this.player2State !== 'down') {\n                    this.player2.play('p2_down', true);\n                    this.player2.setFlipX(true);\n                    this.player2State = 'down';\n                }\n            } else if (this.player2State !== 'idle') {\n                // Only play idle if game is not over\n                if (!this.gameOver) this.player2.play('p2_idle', true);\n                this.player2.setFlipX(true);\n                this.player2State = 'idle';\n            }\n        }\n        // Debug: log V key state and player1State\n        this.keys && this.keys.v;\n        // console.log('[DEBUG] player1State:', this.player1State);\n        // Debug: check if we reach attack check\n        // console.log('[DEBUG] Before attack check');\n        // Use isDown + cooldown for V key\n        const now = time;\n        const attackCondition = this.keys && this.keys.v && this.keys.v.isDown && now > (this.lastAttackTime?.[0] || 0) + $efd3ba4ec2608b1d$var$ATTACK_COOLDOWN && this.player1State !== 'attack' && this.player1State !== 'special' || this._touchJustPressedP1A && this.player1State !== 'attack' && this.player1State !== 'special';\n        // console.log('[DEBUG] Attack condition:', attackCondition, 'isDown:', this.keys.v.isDown, 'lastAttackTime:', this.lastAttackTime?.[0], 'now:', now, '_touchJustPressedP1A:', this._touchJustPressedP1A);\n        // Player 1 attack (V key or touch)\n        if (attackCondition) {\n            // Always reset touch flag after attack (fixes mobile bug)\n            this._touchJustPressedP1A = false;\n            // console.log('[DEBUG] Attack block entered, player1:', this.player1);\n            // Now always allowed to attack here, no further state check needed\n            // console.log('[DEBUG] Triggering attack animation');\n            // console.log('[DEBUG] Anim exists:', this.anims.exists('p1_attack'));\n            this.player1.play('p1_attack', true);\n            this.player1State = 'attack';\n            // console.log('[DEBUG] player1State set to:', this.player1State);\n            // Deal damage to player2 if in range\n            console.log('[DEBUG-BEFORE] Player 1 attacks Player 2. Player 2 health:', this.playerHealth[1]);\n            (0, $4244f6a75d6df63d$export$d918436b04969c89)(this, 0, this.player1, this.player2, now, false);\n            console.log('[DEBUG-AFTER] Player 1 attacks Player 2. Player 2 health:', this.playerHealth[1]);\n            const healthRatio = Math.max(0, this.playerHealth[1] / $efd3ba4ec2608b1d$var$MAX_HEALTH);\n            this.healthBar2.width = 200 * healthRatio;\n            // Manually switch to idle after 400ms\n            this.time.delayedCall(400, ()=>{\n                if (this.player1State === 'attack' && !this.gameOver) {\n                    this.player1.play('p1_idle', true);\n                    this.player1State = 'idle';\n                // console.log('[DEBUG] player1State set to:', this.player1State);\n                }\n            });\n        }\n        // Player 1 special (B key or touch)\n        const specialConditionP1 = this.keys && this.keys.b && this.keys.b.isDown && this.player1State !== 'attack' && this.player1State !== 'special' && this.attackCount[0] >= 3 || this._touchJustPressedP1S && this.player1State !== 'attack' && this.player1State !== 'special' && this.attackCount[0] >= 3;\n        if (specialConditionP1) {\n            this._touchJustPressedP1S = false;\n            this.player1.play('p1_special', true);\n            this.player1State = 'special';\n            (0, $4244f6a75d6df63d$export$d918436b04969c89)(this, 0, this.player1, this.player2, now, true);\n            const healthRatio = Math.max(0, this.playerHealth[1] / $efd3ba4ec2608b1d$var$MAX_HEALTH);\n            this.healthBar2.width = 200 * healthRatio;\n            this.showSpecialEffect(this.player1.x, this.player1.y - 60);\n            this.time.delayedCall(700, ()=>{\n                if (this.player1State === 'special' && !this.gameOver) {\n                    this.player1.play('p1_idle', true);\n                    this.player1State = 'idle';\n                    // Reset special pips after special is used\n                    this.attackCount[0] = 0;\n                }\n            });\n        }\n        // Player 2 attack (; key or K key or touch)\n        const attackConditionP2 = this.keys && (this.keys.semicolon && this.keys.semicolon.isDown || this.keys.k && this.keys.k.isDown) && now > (this.lastAttackTime?.[1] || 0) + $efd3ba4ec2608b1d$var$ATTACK_COOLDOWN && this.player2State !== 'attack' && this.player2State !== 'special' || this._touchJustPressedP2A && this.player2State !== 'attack' && this.player2State !== 'special';\n        if (attackConditionP2) {\n            // Always reset touch flag after attack (fixes mobile bug for Player 2)\n            this._touchJustPressedP2A = false;\n            this.player2.play('p2_attack', true);\n            this.player2State = 'attack';\n            // console.log('[DEBUG] Player 2 attack');\n            (0, $4244f6a75d6df63d$export$d918436b04969c89)(this, 1, this.player2, this.player1, now, false);\n            const healthRatio1 = Math.max(0, this.playerHealth[0] / $efd3ba4ec2608b1d$var$MAX_HEALTH);\n            this.healthBar1.width = 200 * healthRatio1;\n            this.time.delayedCall(400, ()=>{\n                if (this.player2State === 'attack' && !this.gameOver) {\n                    this.player2.play('p2_idle', true);\n                    this.player2State = 'idle';\n                }\n            });\n        }\n        // Player 2 special (L key or touch)\n        const specialConditionP2 = this.keys && this.keys.l && this.keys.l.isDown && this.player2State !== 'attack' && this.player2State !== 'special' && this.attackCount[1] >= 3 || this._touchJustPressedP2S && this.player2State !== 'attack' && this.player2State !== 'special' && this.attackCount[1] >= 3;\n        if (specialConditionP2) {\n            this._touchJustPressedP2S = false;\n            this.player2.play('p2_special', true);\n            this.player2State = 'special';\n            (0, $4244f6a75d6df63d$export$d918436b04969c89)(this, 1, this.player2, this.player1, now, true);\n            const healthRatio1 = Math.max(0, this.playerHealth[0] / $efd3ba4ec2608b1d$var$MAX_HEALTH);\n            this.healthBar1.width = 200 * healthRatio1;\n            this.showSpecialEffect(this.player2.x, this.player2.y - 60);\n            this.time.delayedCall(700, ()=>{\n                if (this.player2State === 'special' && !this.gameOver) {\n                    this.player2.play('p2_idle', true);\n                    this.player2State = 'idle';\n                    // Reset special pips after special is used\n                    this.attackCount[1] = 0;\n                }\n            });\n        }\n    }\n    updateSceneLayout() {\n        return (0, $4244f6a75d6df63d$export$2ba455e6ae328961)(this);\n    }\n    // --- GAME OVER HANDLER ---\n    endGame(phrase) {\n        if (this.gameOver) return;\n        this.gameOver = true;\n        // Centered winning phrase\n        const winText = this.add.text(this.cameras.main.width / 2, this.cameras.main.height / 2, phrase, {\n            fontSize: Math.max(20, Math.min(36, Math.round(this.cameras.main.width * 0.055))) + 'px',\n            color: '#fff',\n            fontFamily: 'monospace',\n            stroke: '#000',\n            strokeThickness: 8,\n            align: 'center',\n            backgroundColor: 'rgba(0,0,0,0.35)',\n            padding: {\n                left: Math.round(this.cameras.main.width * 0.025),\n                right: Math.round(this.cameras.main.width * 0.025),\n                top: Math.round(this.cameras.main.width * 0.012),\n                bottom: Math.round(this.cameras.main.width * 0.012)\n            }\n        }).setOrigin(0.5).setDepth(10001);\n        // Optionally, fade in the text\n        winText.setAlpha(0);\n        this.tweens.add({\n            targets: winText,\n            alpha: 1,\n            duration: 400\n        });\n        // --- Add 'Jogar Novamente' button ---\n        const btnY = this.cameras.main.height / 2 + 90;\n        const playAgainBtn = this.add.text(this.cameras.main.width / 2, btnY, 'Jogar Novamente', {\n            fontSize: Math.max(18, Math.min(30, Math.round(this.cameras.main.width * 0.045))) + 'px',\n            color: '#fff',\n            backgroundColor: '#44aaff',\n            fontFamily: 'monospace',\n            padding: {\n                left: Math.round(this.cameras.main.width * 0.02),\n                right: Math.round(this.cameras.main.width * 0.02),\n                top: Math.round(this.cameras.main.width * 0.01),\n                bottom: Math.round(this.cameras.main.width * 0.01)\n            },\n            align: 'center',\n            stroke: '#000',\n            strokeThickness: 8,\n            borderRadius: 24\n        }).setOrigin(0.5).setDepth(10002).setAlpha(0).setInteractive({\n            useHandCursor: true\n        });\n        this.tweens.add({\n            targets: playAgainBtn,\n            alpha: 1,\n            duration: 400,\n            delay: 200\n        });\n        playAgainBtn.on('pointerdown', ()=>{\n            winText.destroy();\n            playAgainBtn.destroy();\n            this.scene.restart();\n        });\n        // Winner celebrates, loser lays down\n        if (this.player1 && this.player2) {\n            const p1Dead = this.playerHealth[0] <= 0;\n            const p2Dead = this.playerHealth[1] <= 0;\n            if (p1Dead && !p2Dead) {\n                // Player 2 wins\n                this.player2.setFrame(3); // Winner celebrates\n                this.player2.setFlipX(true);\n                this.player2.setAngle(0);\n                this.player1.setFrame(4); // Loser lays down (frame 4)\n                this.player1.setFlipX(false);\n                this.player1.setAngle(270);\n                this.showSpecialEffect(this.player1.x, this.player1.y);\n            } else if (p2Dead && !p1Dead) {\n                // Player 1 wins\n                this.player1.setFrame(3); // Winner celebrates\n                this.player1.setFlipX(false);\n                this.player1.setAngle(0);\n                this.player2.setFrame(4); // Loser lays down (frame 4)\n                this.player2.setFlipX(true);\n                this.player2.setAngle(270);\n                this.showSpecialEffect(this.player2.x, this.player2.y);\n            } else {\n                // Draw or both dead: both use frame 5\n                this.player1.setFrame(5); // Both use frame 5 for draw\n                this.player1.setFlipX(false);\n                // No rotation for draw\n                this.player2.setFrame(5);\n                this.player2.setFlipX(true);\n                // No rotation for draw\n                this.showSpecialEffect(this.player1.x, this.player1.y);\n                this.showSpecialEffect(this.player2.x, this.player2.y);\n            }\n        }\n        if (this.player1 && this.player1.anims) this.player1.anims.stop();\n        if (this.player2 && this.player2.anims) this.player2.anims.stop();\n        // Freeze winner in frame 3 (celebration) after win\n        if (this.player1.frame.name === 3) this.player1.setFrame(3);\n        if (this.player2.frame.name === 3) this.player2.setFrame(3);\n    // Do not remove input listeners; rely on this.gameOver = true to block input after game over.\n    // This avoids breaking keyboard input after scene restart.\n    }\n}\nfunction $efd3ba4ec2608b1d$var$resizeGame(game) {\n    // Use window.innerWidth/innerHeight for true viewport size (accounts for mobile browser UI)\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n    game.scale.resize(w, h);\n    (0, $4244f6a75d6df63d$export$36c7bbefcce976d2)();\n}\n// --- Responsive Touch Controls Positioning ---\n$efd3ba4ec2608b1d$var$KidsFightScene.prototype.updateControlPositions = function() {\n    if (!this.isTouch || !this.touchControls || !this.cameras || !this.cameras.main) return;\n    const cam = this.cameras.main;\n    const w = cam.width;\n    const h = cam.height;\n    // Player 1\n    this.touchControls.p1.left.setPosition(w * 0.08, h * 0.85);\n    this.touchControls.p1.right.setPosition(w * 0.18, h * 0.85);\n    this.touchControls.p1.jump.setPosition(w * 0.13, h * 0.7);\n    this.touchControls.p1.down.setPosition(w * 0.13, h * 0.97);\n    this.touchControls.p1.attack.setPosition(w * 0.28, h * 0.89);\n    this.touchControls.p1.special.setPosition(w * 0.36, h * 0.89);\n    // Player 2\n    this.touchControls.p2.left.setPosition(w * 0.82, h * 0.85);\n    this.touchControls.p2.right.setPosition(w * 0.92, h * 0.85);\n    this.touchControls.p2.jump.setPosition(w * 0.87, h * 0.7);\n    this.touchControls.p2.down.setPosition(w * 0.87, h * 0.97);\n    this.touchControls.p2.attack.setPosition(w * 0.72, h * 0.89);\n    this.touchControls.p2.special.setPosition(w * 0.64, h * 0.89);\n    // Labels (order must match creation)\n    if (this.touchLabels && this.touchLabels.length === 12) {\n        this.touchLabels[0].setPosition(w * 0.06, h * 0.83);\n        this.touchLabels[1].setPosition(w * 0.16, h * 0.83);\n        this.touchLabels[2].setPosition(w * 0.11, h * 0.68);\n        this.touchLabels[3].setPosition(w * 0.11, h * 0.95);\n        this.touchLabels[4].setPosition(w * 0.25, h * 0.87);\n        this.touchLabels[5].setPosition(w * 0.33, h * 0.87);\n        this.touchLabels[6].setPosition(w * 0.79, h * 0.83);\n        this.touchLabels[7].setPosition(w * 0.89, h * 0.83);\n        this.touchLabels[8].setPosition(w * 0.84, h * 0.68);\n        this.touchLabels[9].setPosition(w * 0.84, h * 0.95);\n        this.touchLabels[10].setPosition(w * 0.69, h * 0.87);\n        this.touchLabels[11].setPosition(w * 0.61, h * 0.87);\n    }\n};\n// Phaser Game Config (must be after KidsFightScene is defined)\nconst $efd3ba4ec2608b1d$var$config = {\n    type: Phaser.AUTO,\n    width: $efd3ba4ec2608b1d$var$GAME_WIDTH,\n    height: $efd3ba4ec2608b1d$var$GAME_HEIGHT,\n    backgroundColor: '#222',\n    parent: 'game-container',\n    scene: $efd3ba4ec2608b1d$var$KidsFightScene,\n    physics: {\n        default: 'arcade',\n        arcade: {\n            gravity: {\n                y: $efd3ba4ec2608b1d$var$GRAVITY\n            },\n            debug: false\n        }\n    },\n    scale: {\n        mode: Phaser.Scale.RESIZE,\n        autoCenter: Phaser.Scale.CENTER_BOTH\n    }\n};\nwindow.onload = ()=>{\n    // Set initial size to fit screen\n    $efd3ba4ec2608b1d$var$config.width = window.innerWidth;\n    $efd3ba4ec2608b1d$var$config.height = window.innerHeight;\n    $efd3ba4ec2608b1d$var$config.scale.width = window.innerWidth;\n    $efd3ba4ec2608b1d$var$config.scale.height = window.innerHeight;\n    const game = new Phaser.Game($efd3ba4ec2608b1d$var$config);\n    // Initial resize to account for mobile browser UI\n    $efd3ba4ec2608b1d$var$resizeGame(game);\n    // Helper: double-resize to fix mobile browser chrome issues\n    function resizeWithDelay() {\n        $efd3ba4ec2608b1d$var$resizeGame(game);\n        setTimeout(()=>$efd3ba4ec2608b1d$var$resizeGame(game), 250); // Second resize after browser chrome settles\n    }\n    window.addEventListener('resize', resizeWithDelay);\n    window.addEventListener('orientationchange', resizeWithDelay);\n};\n\n\n//# sourceMappingURL=kidsfight.81e35bcd.js.map\n","// Parcel image imports for Phaser asset loading\nimport scenario1Img from './scenario1.png?url';\nimport player1RawImg from './sprites-bento3.png?url';\nimport player2RawImg from './sprites-davir3.png?url';\n\n// Import pure utilities for testability\nimport { updateSceneLayout, applyGameCss, tryAttack } from './gameUtils.mjs';\n\n\n// Dynamically set game size based on viewport, accounting for mobile browser UI\nconst GAME_WIDTH = window.innerWidth;\nconst GAME_HEIGHT = window.innerHeight;\n\nconst PLAYER_SIZE = 192;\nconst PLAYER_SPEED = 200;\nconst JUMP_VELOCITY = -400;\nconst GRAVITY = 900;\nconst ATTACK_RANGE = 100;\nconst ATTACK_COOLDOWN = 500;\nconst MAX_HEALTH = 100;\n\nconst ROUND_TIME = 60;\n\n// import PlayerSelectScene from './player_select_scene.js';\n\n\nclass KidsFightScene extends Phaser.Scene {\n  // --- EFFECTS: Special Effect Helper (Phaser 3.60+ workaround) ---\n  showSpecialEffect(x, y, count = 30) {\n    if (!this.specialEffect) return;\n    this.specialEffect.clear();\n    this.specialEffect.setVisible(true);\n    this.specialEffect.setAlpha(1);\n    this.specialEffect.setScale(1);\n    this.specialEffect.lineStyle(8, 0x00eaff, 0.7);\n    this.specialEffect.strokeCircle(x, y, 20);\n    this.tweens.add({\n      targets: this.specialEffect,\n      alpha: 0,\n      scaleX: 2,\n      scaleY: 2,\n      duration: 350,\n      onComplete: () => {\n        this.specialEffect.clear();\n        this.specialEffect.setVisible(false);\n        this.specialEffect.setAlpha(1);\n        this.specialEffect.setScale(1);\n      }\n    });\n  }\n\n  constructor() {\n    super('KidsFightScene');\n    this.lastAttackTime = [0, 0];\n    this.attackCount = [0, 0]; // Counts normal attacks landed by each player\n    this.lungeTimer = [0, 0]; // Initialize lunge timers for both players\n    this.timeLeft = 60;\n    this.player1State = 'idle';\n// console.log('[DEBUG] player1State set to:', this.player1State); // 'idle', 'down', 'attack', 'special'\n    this.player2State = 'idle';\n    // // console.log('[constructor] timeLeft:', this.timeLeft, 'ROUND_TIME:', typeof ROUND_TIME !== 'undefined' ? ROUND_TIME : 'undefined');\n  }\n\n  init(data) {\n    this.selected = data || { p1: 0, p2: 1 };\n  }\n\n  preload() {\n    // Debug: Print imported image URLs and types\n    // console.log('scenario1Img', scenario1Img, typeof scenario1Img);\n    // console.log('player1RawImg', player1RawImg, typeof player1RawImg);\n    // console.log('player2RawImg', player2RawImg, typeof player2RawImg);\n    // Load player sprite sheets (256x256)\n    this.load.image('player1_raw', player1RawImg);\n    this.load.image('player2_raw', player2RawImg);\n    // Load scenario background\n    this.load.image('scenario1', scenario1Img);\n    // Load particle spritesheet for effects\n    //this.load.atlas('flares', 'flares.png', 'flares.json');\n  }\n\n  create() {\n    // --- RESET ALL GAME STATE ON RESTART ---\n    this.gameOver = false;\n    this.player1State = 'idle';\n    this.player2State = 'idle';\n    this.lastAttackTime = [0, 0];\n    this.attackCount = [0, 0];\n    this.lungeTimer = [0, 0];\n    this.timeLeft = 60;\n    this.playerHealth = [MAX_HEALTH, MAX_HEALTH];\n    // console.log('[DEBUG] create() this:', this, 'scene key:', this.sys && this.sys.settings && this.sys.settings.key);\n    // --- CREATE CUSTOM SPRITESHEETS FIRST ---\n    // Player 1\n    if (!this.textures.exists('player1')) {\n      const frameWidths = [300, 300, 400, 460, 500, 440, 440, 440];\n      const frameHeight = 512;\n      const player1Texture = this.textures.get('player1_raw').getSourceImage();\n      this.textures.addSpriteSheet('player1', player1Texture, {\n        frameWidth: 430,\n        frameHeight: frameHeight,\n        startFrame: 0,\n        endFrame: 6\n      });\n      const tex = this.textures.get('player1');\n      tex.frames = { __BASE: tex.frames['__BASE'] };\n      let x = 0;\n      for (let i = 0; i < frameWidths.length; i++) {\n        tex.add(i, 0, x, 0, frameWidths[i], frameHeight);\n        x += frameWidths[i];\n      }\n    }\n    // Player 2\n    if (!this.textures.exists('player2')) {\n      const frameWidths2 = [300, 300, 400, 460, 500, 400, 400, 400];\n      const frameHeight2 = 512;\n      const player2Texture = this.textures.get('player2_raw').getSourceImage();\n      this.textures.addSpriteSheet('player2', player2Texture, {\n        frameWidth: 400,\n        frameHeight: frameHeight2,\n        startFrame: 0,\n        endFrame: frameWidths2.length - 1\n      });\n      const tex2 = this.textures.get('player2');\n      tex2.frames = { __BASE: tex2.frames['__BASE'] };\n      let x2 = 0;\n      for (let i = 0; i < frameWidths2.length; i++) {\n        tex2.add(i, 0, x2, 0, frameWidths2[i], frameHeight2);\n        x2 += frameWidths2[i];\n      }\n    }\n    // Add background image\n\n    const bg = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'scenario1').setOrigin(0.5, 0.5);\n    bg.displayWidth = GAME_WIDTH;\n    bg.displayHeight = GAME_HEIGHT;\n\n    // Ensure world and camera bounds match the visible area (for mobile/responsive)\n    const cam = this.cameras.main;\n    if (this.isTouch) {\n      // Decrease bounds by 10% on each side for mobile\n      const padX = cam.width * 0.1;\n      const padY = cam.height * 0.05;\n      this.physics.world.setBounds(padX, padY, cam.width - 2 * padX, cam.height - 2 * padY);\n      this.cameras.main.setBounds(padX, padY, cam.width - 2 * padX, cam.height - 2 * padY);\n    } else {\n      this.physics.world.setBounds(0, 0, cam.width, cam.height);\n      this.cameras.main.setBounds(0, 0, cam.width, cam.height);\n    }\n    // --- TOUCH CONTROLS ---\n    this.touchControls = { p1: {}, p2: {} };\n    // Robust touch detection (works on iOS and all browsers)\n    const debugAlwaysShowTouch = false; // set to true to force show for debugging\n    this.isTouch = debugAlwaysShowTouch || (typeof window !== 'undefined' && (\n      (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||\n      ('ontouchstart' in window)\n    ));\n    if (this.isTouch) {\n      const cam = this.cameras.main;\n      const w = cam.width;\n      const h = cam.height;\n      // Player 1 (left side) - relative positions\n      this.touchControls.p1.left = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p1.right = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p1.jump = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p1.down = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p1.attack = this.add.circle(0, 0, 30, 0xff4444, 0.8).setInteractive().setDepth(9999);\n      this.touchControls.p1.special = this.add.circle(0, 0, 30, 0xffd700, 0.8).setInteractive().setDepth(9999);\n      // Player 2 (right side) - relative positions\n      this.touchControls.p2.left = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p2.right = this.add.rectangle(0, 0, 48, 48, 0x444444, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p2.jump = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p2.down = this.add.rectangle(0, 0, 48, 48, 0x888888, 0.7).setInteractive().setDepth(9999);\n      this.touchControls.p2.attack = this.add.circle(0, 0, 30, 0x44aaff, 0.8).setInteractive().setDepth(9999);\n      this.touchControls.p2.special = this.add.circle(0, 0, 30, 0xffd700, 0.8).setInteractive().setDepth(9999);\n      // Touch flags\n      this.touchFlags = { p1: {left:false,right:false,jump:false,down:false,attack:false,special:false}, p2: {left:false,right:false,jump:false,down:false,attack:false,special:false} };\n      // Setup touch events for all buttons\n      const setupBtn = (btn, flagObj, flag) => {\n        btn.on('pointerdown', ()=>{flagObj[flag]=true;});\n        btn.on('pointerup', ()=>{flagObj[flag]=false;});\n        btn.on('pointerout', ()=>{flagObj[flag]=false;});\n        btn.on('pointerupoutside', ()=>{flagObj[flag]=false;});\n      };\n      Object.entries(this.touchControls.p1).forEach(([k,btn])=>setupBtn(btn, this.touchFlags.p1, k));\n      Object.entries(this.touchControls.p2).forEach(([k,btn])=>setupBtn(btn, this.touchFlags.p2, k));\n      // Add icons/labels (also relative)\n      this.touchLabels = [];\n      this.touchLabels.push(this.add.text(0, 0, '<', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, '>', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, '^', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'v', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'A', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'S', {fontSize:'24px',color:'#222'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, '<', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, '>', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, '^', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'v', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'A', {fontSize:'24px',color:'#fff'}).setDepth(10000));\n      this.touchLabels.push(this.add.text(0, 0, 'S', {fontSize:'24px',color:'#222'}).setDepth(10000));\n      // Immediately position all touch labels\n      this.updateControlPositions();\n    }\n    \n\n    // --- EFFECTS ---\n    // Hit flash effect for attacks\n    this.hitFlash = this.add.graphics({ x: 0, y: 0 }).setDepth(999);\n    this.hitFlash.setVisible(false);\n    // Particle system and emitter for special attacks\n    // Simple custom effect for special attacks (Phaser 3.60+ workaround)\n    this.specialEffect = this.add.graphics({ x: 0, y: 0 }).setDepth(998);\n    this.specialEffect.setVisible(false);\n\n\n\n  // --- EFFECTS ---\n  // --- PLAYER SPAWN LOGIC (moved from orphaned code) ---\n  const playerSprites = ['player1', 'player2'];\n  // Responsive player scale based on height (target ~38% of screen height)\n  const scale = (GAME_HEIGHT * 0.38) / 512;\n  const frameHeight = 512;\n  const player1FrameWidths = [300, 300, 430, 580, 580, 440, 440, 440];\n\n  // Align player feet to the ground (bottom of the screen)\n  const frameWidth = player1FrameWidths[0];\n  const bodyWidth = frameWidth * scale;\n  const bodyHeight = frameHeight * scale;\n  // player.y is the center, so set: playerY = GAME_HEIGHT - (this.textures.get('player1').getSourceImage().height * scale) / 2;\n// But we can use the actual sprite height after creation for precision\n  // Responsive platform position and height\n  const PLATFORM_Y = GAME_HEIGHT * 0.7; // 70% down the screen (lower for desktop)\n  const PLATFORM_HEIGHT = GAME_HEIGHT * 0.045; // 4.5% of screen height\n  // Add background image\n  \n  bg.displayWidth = GAME_WIDTH;\n  bg.displayHeight = GAME_HEIGHT;\n\n  // Draw the platform rectangle above the background\n  const platformRect = this.add.rectangle(GAME_WIDTH / 2, PLATFORM_Y + PLATFORM_HEIGHT / 2, GAME_WIDTH, PLATFORM_HEIGHT, 0x8B5A2B).setDepth(2).setVisible(false);\n  // Add static physics body for the platform\n  const platform = this.physics.add.staticGroup();\n  platform.create(GAME_WIDTH / 2, PLATFORM_Y + PLATFORM_HEIGHT / 2, null)\n    .setDisplaySize(GAME_WIDTH, PLATFORM_HEIGHT)\n    .setVisible(false)\n    .refreshBody();\n\n  // --- DEFENSIVE: Ensure valid selected and sprite keys ---\n  const playerSpritesSafe = ['player1', 'player2'];\n  const selectedSafe = (this.selected && typeof this.selected.p1 === 'number' && typeof this.selected.p2 === 'number') ? this.selected : { p1: 0, p2: 1 };\n  const p1Key = playerSpritesSafe[selectedSafe.p1] || 'player1';\n  const p2Key = playerSpritesSafe[selectedSafe.p2] || 'player2';\n  const PLAYER_PLATFORM_OFFSET = 20;\n  // Responsive player spawn positions\n  const p1X = GAME_WIDTH * 0.25;\n  const p2X = GAME_WIDTH * 0.75;\n  const playerY = PLATFORM_Y + PLAYER_PLATFORM_OFFSET;\n  this.player1 = this.physics.add.sprite(p1X, playerY, p1Key, 0);\n  this.player1.setScale(scale);\n  this.player1.setOrigin(0.5, 1); // bottom center\n  this.player1.body.setSize(this.player1.displayWidth, this.player1.displayHeight);\n  this.player1.body.setOffset(0, 0);\n  // Enable collision with platform\n  this.physics.add.collider(this.player1, platform);\n  this.player1.setCollideWorldBounds(true);\n  this.player1.setBounce(0.1);\n  this.player1.facing = 1;\n\n  this.player2 = this.physics.add.sprite(p2X, playerY, p2Key, 0);\n  this.player2.setScale(scale);\n  this.player2.setOrigin(0.5, 1); // bottom center\n  this.player2.body.setSize(this.player2.displayWidth, this.player2.displayHeight);\n  this.player2.body.setOffset(0, 0);\n  // Enable collision with platform\n  this.physics.add.collider(this.player2, platform);\n  this.player2.setCollideWorldBounds(true);\n  this.player2.setBounce(0.1);\n  this.player2.facing = -1;\n  this.player2.setFlipX(true); // Invert horizontally\n\n    // Player 1 Animations (custom frames)\n    if (!this.anims.exists('p1_idle')) {\n      this.anims.create({\n        key: 'p1_idle',\n        frames: [{ key: 'player1', frame: 0 }],\n        frameRate: 1,\n        repeat: -1\n      });\n    }\n    if (!this.anims.exists('p1_walk')) {\n      this.anims.create({\n        key: 'p1_walk',\n        frames: [\n          { key: 'player1', frame: 1 },\n          { key: 'player1', frame: 2 }\n        ],\n        frameRate: 6,\n        repeat: -1\n      });\n    }\n    if (!this.anims.exists('p1_attack')) {\n      this.anims.create({\n        key: 'p1_attack',\n        frames: [{ key: 'player1', frame: 4 }], // Use frame 4 for hit\n        frameRate: 1,\n        repeat: 0,\n        duration: 200 // Show hit frame for 200ms\n      });\n    }\n    if (!this.anims.exists('p1_special')) {\n      this.anims.create({\n        key: 'p1_special',\n        frames: [{ key: 'player1', frame: 6 }], // Use frame 6 for special\n        frameRate: 1,\n        repeat: 0,\n        duration: 900 // Show special frame for 900ms\n      });\n    }\n    // Down/crouch animations\n    if (!this.anims.exists('p1_down')) {\n      this.anims.create({\n        key: 'p1_down',\n        frames: [{ key: 'player1', frame: 5 }], // Use 6th image (index 5)\n        frameRate: 1,\n        repeat: -1\n      });\n    }\n\n    // Animations\n    if (!this.anims.exists('p2_idle')) {\n      this.anims.create({\n        key: 'p2_idle',\n        frames: [{ key: 'player2', frame: 0 }],\n        frameRate: 1,\n        repeat: -1\n      });\n    }\n    if (!this.anims.exists('p2_walk')) {\n      this.anims.create({\n        key: 'p2_walk',\n        frames: [\n          { key: 'player2', frame: 0 },\n          { key: 'player2', frame: 1 }\n        ],\n        frameRate: 6,\n        repeat: -1\n      });\n    }\n    if (!this.anims.exists('p2_attack')) {\n      this.anims.create({\n        key: 'p2_attack',\n        frames: [{ key: 'player2', frame: 4 }], // Use frame 4 for hit\n        frameRate: 1,\n        repeat: 0,\n        duration: 200 // Show hit frame for 200ms\n      });\n    }\n    if (!this.anims.exists('p2_down')) {\n      this.anims.create({\n        key: 'p2_down',\n        frames: [{ key: 'player2', frame: 5 }], // Use 6th image (index 5)\n        frameRate: 1,\n        repeat: -1\n      });\n    }\n    if (!this.anims.exists('p2_special')) {\n      this.anims.create({\n        key: 'p2_special',\n        frames: [{ key: 'player2', frame: 6 }], // Use frame 6 for special\n        frameRate: 1,\n        repeat: 0,\n        duration: 900 // Show special frame for 900ms\n      });\n    }\n    this.player1.play('p1_idle');\n    this.player1.angle = 0;\n    this.player2.angle = 0;\n    // Reset loser y offset (in case of rematch)\n    this.playerY = playerY; // Store globally for use in endGame\n    if (!this.gameOver) this.player2.play('p2_idle');\n    // Store original Y for laying down math\n    this.player1._originalY = this.player1.y;\n    this.player2._originalY = this.player2.y;\n\n    // Animation complete: return to idle after attack\n    // (Replaced by manual timer for attack/special)\n    // this.player1.on('animationcomplete', ...)\n    // this.player2.on('animationcomplete', ...)\n\n    // Collisions\n    this.physics.add.collider(this.player1, this.floatPlatform);\n    this.physics.add.collider(this.player2, this.floatPlatform);\n\n    // Controls\n    this.cursors = this.input.keyboard.createCursorKeys();\n    this.keys = this.input.keyboard.addKeys({\n      a: 'A', d: 'D', w: 'W', // P1 movement\n      v: 'V', b: 'B', n: 'N', s: 'S', // P1: V = attack, B = special, N/S = down/crouch\n      k: 'K', l: 'L', semicolon: 'SEMICOLON'\n    });\n    // Defensive: ensure all keys exist even if not mapped\n    const keyList = ['a','d','w','v','b','n','s','k','l','semicolon'];\n    for (const k of keyList) {\n      if (!this.keys[k]) this.keys[k] = { isDown: false };\n    }\n    // Debug: log at end of create()\n    // console.log('[DEBUG] create() called, this.keys:', this.keys);\n    // Global keydown debug (disable for touch)\n    if (!this.isTouch) {\n      window.addEventListener('keydown', function(e) {\n        // console.log('[GLOBAL] Key pressed:', e.key, 'code:', e.code);\n      });\n    }\n\n    // Health bars\n    this.healthBar1Border = this.add.rectangle(200, 30, 204, 24, 0xffffff).setOrigin(0.5);\n    this.healthBar2Border = this.add.rectangle(600, 30, 204, 24, 0xffffff).setOrigin(0.5);\n    this.healthBar1Border.setStrokeStyle(2, 0x000000);\n    this.healthBar2Border.setStrokeStyle(2, 0x000000);\n    this.healthBar1 = this.add.rectangle(200, 30, 200, 20, 0xff4444);\n    this.healthBar2 = this.add.rectangle(600, 30, 200, 20, 0x44aaff);\n    this.healthBar1.setOrigin(0.5);\n    this.healthBar2.setOrigin(0.5);\n    this.children.bringToTop(this.healthBar1);\n    this.children.bringToTop(this.healthBar2);\n\n    // --- SPECIAL HIT CIRCLES (PIPS) ---\n    // Player 1 special pips (left, above health bar)\n    this.specialPips1 = [];\n    for (let i = 0; i < 3; i++) {\n      const pip = this.add.circle(140 + i * 30, 16, 10, 0x888888, 0.8).setStrokeStyle(2, 0x000).setDepth(10);\n      pip.setVisible(true);\n      this.specialPips1.push(pip);\n    }\n    // Player 2 special pips (right, above health bar)\n    this.specialPips2 = [];\n    for (let i = 0; i < 3; i++) {\n      const pip = this.add.circle(540 + i * 30, 16, 10, 0x888888, 0.8).setStrokeStyle(2, 0x000).setDepth(10);\n      pip.setVisible(true);\n      this.specialPips2.push(pip);\n    }\n    // Ensure all pips are reset to gray and visible\n    this.specialPips1.forEach(pip => pip.setFillStyle(0x888888).setVisible(true));\n    this.specialPips2.forEach(pip => pip.setFillStyle(0x888888).setVisible(true));\n    // Hide special ready circles\n    if (this.specialReady1) this.specialReady1.setVisible(false);\n    if (this.specialReadyText1) this.specialReadyText1.setVisible(false);\n    if (this.specialReady2) this.specialReady2.setVisible(false);\n    if (this.specialReadyText2) this.specialReadyText2.setVisible(false);\n\n    // --- SPECIAL READY CIRCLE (BIG S) ---\n    // Player 1\n    this.specialReady1 = this.add.circle(200, 60, 22, 0xffd700, 0.93).setStrokeStyle(3, 0x000).setDepth(15).setVisible(false);\n    this.specialReadyText1 = this.add.text(200, 60, 'S', { fontSize: '26px', color: '#000', fontFamily: 'monospace', fontStyle: 'bold' }).setOrigin(0.5).setDepth(16).setVisible(false);\n    // Player 2\n    this.specialReady2 = this.add.circle(600, 60, 22, 0xffd700, 0.93).setStrokeStyle(3, 0x000).setDepth(15).setVisible(false);\n    this.specialReadyText2 = this.add.text(600, 60, 'S', { fontSize: '26px', color: '#000', fontFamily: 'monospace', fontStyle: 'bold' }).setOrigin(0.5).setDepth(16).setVisible(false);\n\n    // Timer text display\n    this.timerText = this.add.text(GAME_WIDTH / 2, 50, Math.ceil(this.timeLeft), {\n      fontSize: '32px',\n      color: '#fff',\n      fontFamily: 'monospace',\n      align: 'center',\n      stroke: '#000',\n      strokeThickness: 4\n    }).setOrigin(0.5);\n\n    // --- FORCE RESIZE after scene (re)start ---\n    if (typeof resizeGame === 'function') {\n      resizeGame(this.game);\n    }\n    // Update all scene layout to match new size\n    this.updateSceneLayout();\n    // Listen for Phaser's resize event and re-apply CSS AND update layout\n    this.scale.on('resize', () => {\n      if (typeof applyGameCss === 'function') {\n        applyGameCss();\n      }\n      if (typeof this.updateSceneLayout === 'function') {\n        this.updateSceneLayout();\n      }\n    });\n  }\n\n\n  update(time, delta) {\n    if (this.gameOver) return;\n    // --- SPECIAL PIPS UPDATE LOGIC ---\n    // Helper: update special pips and indicators for a player\n    const updateSpecialPips = (playerIdx) => {\n      const attackCount = this.attackCount?.[playerIdx] || 0;\n      const pips = playerIdx === 0 ? this.specialPips1 : this.specialPips2;\n      const specialReady = playerIdx === 0 ? this.specialReady1 : this.specialReady2;\n      const specialReadyText = playerIdx === 0 ? this.specialReadyText1 : this.specialReadyText2;\n      // Show yellow for each attack landed, up to 3, but hide all after 3\n      if (attackCount >= 3) {\n        // Hide all pips\n        for (let i = 0; i < 3; i++) {\n          if (pips[i]) pips[i].setVisible(false);\n        }\n        if (specialReady) specialReady.setVisible(true);\n        if (specialReadyText) specialReadyText.setVisible(true);\n      } else {\n        for (let i = 0; i < 3; i++) {\n          if (pips[i]) {\n            pips[i].setFillStyle(i < attackCount ? 0xffd700 : 0x888888).setVisible(true);\n          }\n        }\n        if (specialReady) specialReady.setVisible(false);\n        if (specialReadyText) specialReadyText.setVisible(false);\n      }\n    };\n    // Call for both players\n    updateSpecialPips(0);\n    updateSpecialPips(1);\n    // console.log('[DEBUG] update() this:', this, 'scene key:', this.sys && this.sys.settings && this.sys.settings.key);\n    if (!this.keys || !this.keys.v) {\n      // console.log('[DEBUG] this.keys or this.keys.v is undefined in update()');\n      return;\n    }\n    // Debug: confirm update is running\n    // console.log('[DEBUG] Update running');\n    // --- TOUCH CONTROLS: map to key states ---\n    // --- TOUCH CONTROLS: custom justPressed for attack/special ---\n    if (this.isTouch && this.touchFlags) {\n      // Setup justPressed logic for attack/special\n      if (!this._touchWasDownP1A && this.touchFlags.p1.attack) {\n        this._touchJustPressedP1A = true;\n      }\n      this._touchWasDownP1A = this.touchFlags.p1.attack;\n      if (!this._touchWasDownP1S && this.touchFlags.p1.special) {\n        this._touchJustPressedP1S = true;\n      }\n      this._touchWasDownP1S = this.touchFlags.p1.special;\n      if (!this._touchWasDownP2A && this.touchFlags.p2.attack) {\n        this._touchJustPressedP2A = true;\n      }\n      this._touchWasDownP2A = this.touchFlags.p2.attack;\n      if (!this._touchWasDownP2S && this.touchFlags.p2.special) {\n        this._touchJustPressedP2S = true;\n      }\n      this._touchWasDownP2S = this.touchFlags.p2.special;\n\n      // Map movement keys from touch to key states\n      this.keys.a.isDown = this.touchFlags.p1.left;\n      this.keys.d.isDown = this.touchFlags.p1.right;\n      this.keys.w.isDown = this.touchFlags.p1.jump;\n      this.keys.s.isDown = this.touchFlags.p1.down;\n      this.cursors.left.isDown = this.touchFlags.p2.left;\n      this.cursors.right.isDown = this.touchFlags.p2.right;\n      this.cursors.up.isDown = this.touchFlags.p2.jump;\n      this.cursors.down.isDown = this.touchFlags.p2.down;\n    }\n    // On desktop, do not overwrite keyboard input\n\n\n\n\n    // Timer logic (regressive)\n    if (!this.gameOver) {\n      if (typeof this.lastTimerUpdate !== 'number' || isNaN(this.lastTimerUpdate)) this.lastTimerUpdate = time;\n      if (typeof this.timeLeft !== 'number' || isNaN(this.timeLeft)) {\n        this.timeLeft = ROUND_TIME;\n      }\n      const timerElapsed = Math.floor((time - this.lastTimerUpdate) / 1000);\n      if (timerElapsed > 0) {\n        this.timeLeft = Math.max(0, this.timeLeft - timerElapsed);\n        this.lastTimerUpdate += timerElapsed * 1000;\n      }\n    }\n    // Update timer display\n    if (this.timerText) this.timerText.setText(Math.ceil(this.timeLeft));\n\n    // Invert frames if players cross each other\n    if (this.player1 && this.player2) {\n      if (this.player1.x > this.player2.x) {\n        this.player1.setFlipX(true);  // Face left\n        this.player2.setFlipX(false); // Face right\n      } else {\n        this.player1.setFlipX(false); // Face right\n        this.player2.setFlipX(true);  // Face left\n      }\n    }\n    // Check win/lose by health\n    // Health-based win detection\n    if (!this.gameOver && this.player1 && this.player2) {\n      if (this.playerHealth[0] <= 0) {\n        this.endGame('Davi R Venceu!');\n        return;\n      } else if (this.playerHealth[1] <= 0) {\n        this.endGame('Bento Venceu!');\n        return;\n      }\n    }\n    if (this.timeLeft === 0) {\n      if (this.playerHealth[0] > this.playerHealth[1]) {\n        this.endGame('Bento Venceu!');\n      } else if (this.playerHealth[1] > this.playerHealth[0]) {\n        this.endGame('Davi R Venceu!');\n      } else {\n        this.endGame('Empate!');\n      }\n      return;\n    }\n    // Timer logic (regressive)\n    if (this.timeLeft <= 0 && !this.gameOver) {\n      this.endGame(\"Tempo Esgotado! Empate!\");\n      return;\n    }\n    // Player 1 movement\n    let p1Moving = false;\n    if (this.player1 && this.player1.body) {\n      const p1 = this.player1.body;\n      if (this.lungeTimer[0] > 0) {\n        this.lungeTimer[0] -= delta;\n      } else {\n        p1.setVelocityX(0);\n        if (this.keys.a.isDown) {\n          p1.setVelocityX(-PLAYER_SPEED);\n          p1Moving = true;\n        }\n        if (this.keys.d.isDown) {\n          p1.setVelocityX(PLAYER_SPEED);\n          p1Moving = true;\n        }\n        if (this.keys.w.isDown && p1.onFloor()) p1.setVelocityY(JUMP_VELOCITY);\n      }\n      // Player 1 walk animation\n      if (\n        this.player1State === 'idle' &&\n        p1Moving &&\n        p1.onFloor() &&\n        !this.gameOver\n      ) {\n        if (this.player1.anims.currentAnim?.key !== 'p1_walk') {\n          this.player1.play('p1_walk', true);\n        }\n      } else if (\n        this.player1State === 'idle' &&\n        this.player1.anims.currentAnim?.key === 'p1_walk' &&\n        !this.gameOver\n      ) {\n        if (!this.gameOver) this.player1.play('p1_idle', true);\n      }\n    }\n    // Player 2 movement\n    let p2Moving = false;\n    if (this.player2 && this.player2.body) {\n      const p2 = this.player2.body;\n      if (this.lungeTimer[1] > 0) {\n        this.lungeTimer[1] -= delta;\n      } else {\n        p2.setVelocityX(0);\n        if (this.cursors.left.isDown) {\n          p2.setVelocityX(-PLAYER_SPEED);\n          p2Moving = true;\n        }\n        if (this.cursors.right.isDown) {\n          p2.setVelocityX(PLAYER_SPEED);\n          p2Moving = true;\n        }\n        if (this.cursors.up.isDown && p2.onFloor()) p2.setVelocityY(JUMP_VELOCITY);\n      }\n      // Player 2 walk animation\n      if (\n        this.player2State === 'idle' &&\n        p2Moving &&\n        p2.onFloor() &&\n        !this.gameOver\n      ) {\n        if (this.player2.anims.currentAnim?.key !== 'p2_walk') {\n          this.player2.play('p2_walk', true);\n        }\n      } else if (\n        this.player2State === 'idle' &&\n        this.player2.anims.currentAnim?.key === 'p2_walk' &&\n        !this.gameOver\n      ) {\n        if (!this.gameOver) this.player2.play('p2_idle', true);\n      }\n    }\n\n    // Player 1 crouch (S or N key)\n    if (!this.gameOver) {\n      if (this.player1State === 'attack' || this.player1State === 'special') {\n        // Do not interrupt attack/special\n      } else if (this.keys && ((this.keys.n && this.keys.n.isDown) || (this.keys.s && this.keys.s.isDown))) {\n        if (this.player1State !== 'down') {\n          this.player1.play('p1_down', true);\n          this.player1State = 'down';\n        }\n      } else {\n        if (this.player1State !== 'idle') {\n          // Only play idle if game is not over\n          if (!this.gameOver) this.player1.play('p1_idle', true);\n          this.player1State = 'idle';\n// console.log('[DEBUG] player1State set to:', this.player1State);\n        }\n      }\n    }\n    // Player 2 crouch (Down arrow or ; key)\n    if (!this.gameOver) {\n      if (this.player2State === 'attack' || this.player2State === 'special') {\n        // Do not interrupt attack/special\n      } else if ((this.cursors && this.cursors.down && this.cursors.down.isDown) || (this.keys && this.keys.semicolon && this.keys.semicolon.isDown)) {\n        if (this.player2State !== 'down') {\n          this.player2.play('p2_down', true);\n          this.player2.setFlipX(true);\n          this.player2State = 'down';\n        }\n      } else {\n        if (this.player2State !== 'idle') {\n          // Only play idle if game is not over\n          if (!this.gameOver) this.player2.play('p2_idle', true);\n          this.player2.setFlipX(true);\n          this.player2State = 'idle';\n        }\n      }\n    }\n\n    // Debug: log V key state and player1State\n    if (this.keys && this.keys.v) {\n      // console.log('[DEBUG] V key isDown:', this.keys.v.isDown, 'JustDown:', Phaser.Input.Keyboard.JustDown(this.keys.v));\n    }\n    // console.log('[DEBUG] player1State:', this.player1State);\n    // Debug: check if we reach attack check\n    // console.log('[DEBUG] Before attack check');\n    // Use isDown + cooldown for V key\n    const now = time;\n    const attackCondition = (this.keys && this.keys.v && this.keys.v.isDown && now > (this.lastAttackTime?.[0] || 0) + ATTACK_COOLDOWN && this.player1State !== 'attack' && this.player1State !== 'special') || (this._touchJustPressedP1A && this.player1State !== 'attack' && this.player1State !== 'special');\n    // console.log('[DEBUG] Attack condition:', attackCondition, 'isDown:', this.keys.v.isDown, 'lastAttackTime:', this.lastAttackTime?.[0], 'now:', now, '_touchJustPressedP1A:', this._touchJustPressedP1A);\n    // Player 1 attack (V key or touch)\n    if (attackCondition) {\n      // Always reset touch flag after attack (fixes mobile bug)\n      this._touchJustPressedP1A = false;\n      // console.log('[DEBUG] Attack block entered, player1:', this.player1);\n      // Now always allowed to attack here, no further state check needed\n        // console.log('[DEBUG] Triggering attack animation');\n        // console.log('[DEBUG] Anim exists:', this.anims.exists('p1_attack'));\n        this.player1.play('p1_attack', true);\n        this.player1State = 'attack';\n        // console.log('[DEBUG] player1State set to:', this.player1State);\n        // Deal damage to player2 if in range\n        console.log('[DEBUG-BEFORE] Player 1 attacks Player 2. Player 2 health:', this.playerHealth[1]);\n        tryAttack(this, 0, this.player1, this.player2, now, false);\n        console.log('[DEBUG-AFTER] Player 1 attacks Player 2. Player 2 health:', this.playerHealth[1]);\n        const healthRatio = Math.max(0, this.playerHealth[1] / MAX_HEALTH);\n        this.healthBar2.width = 200 * healthRatio;\n        // Manually switch to idle after 400ms\n        this.time.delayedCall(400, () => {\n          if (this.player1State === 'attack' && !this.gameOver) {\n            this.player1.play('p1_idle', true);\n            this.player1State = 'idle';\n            // console.log('[DEBUG] player1State set to:', this.player1State);\n          }\n        });\n    }\n\n    // Player 1 special (B key or touch)\n    const specialConditionP1 = (\n      this.keys &&\n      this.keys.b && this.keys.b.isDown &&\n      this.player1State !== 'attack' &&\n      this.player1State !== 'special' &&\n      this.attackCount[0] >= 3\n    ) || (this._touchJustPressedP1S && this.player1State !== 'attack' && this.player1State !== 'special' && this.attackCount[0] >= 3);\n    if (specialConditionP1) {\n      this._touchJustPressedP1S = false;\n      this.player1.play('p1_special', true);\n      this.player1State = 'special';\n      tryAttack(this, 0, this.player1, this.player2, now, true);\n      const healthRatio = Math.max(0, this.playerHealth[1] / MAX_HEALTH);\n      this.healthBar2.width = 200 * healthRatio;\n      this.showSpecialEffect(this.player1.x, this.player1.y - 60);\n      this.time.delayedCall(700, () => {\n         if (this.player1State === 'special' && !this.gameOver) {\n           this.player1.play('p1_idle', true);\n           this.player1State = 'idle';\n           // Reset special pips after special is used\n           this.attackCount[0] = 0;\n         }\n       });\n    }\n\n    // Player 2 attack (; key or K key or touch)\n    const attackConditionP2 = (\n      this.keys &&\n      ((this.keys.semicolon && this.keys.semicolon.isDown) || (this.keys.k && this.keys.k.isDown)) &&\n      now > (this.lastAttackTime?.[1] || 0) + ATTACK_COOLDOWN &&\n      this.player2State !== 'attack' &&\n      this.player2State !== 'special'\n    ) || (this._touchJustPressedP2A && this.player2State !== 'attack' && this.player2State !== 'special');\n    if (attackConditionP2) {\n      // Always reset touch flag after attack (fixes mobile bug for Player 2)\n      this._touchJustPressedP2A = false;\n      this.player2.play('p2_attack', true);\n      this.player2State = 'attack';\n      // console.log('[DEBUG] Player 2 attack');\n      tryAttack(this, 1, this.player2, this.player1, now, false);\n      const healthRatio1 = Math.max(0, this.playerHealth[0] / MAX_HEALTH);\n      this.healthBar1.width = 200 * healthRatio1;\n      this.time.delayedCall(400, () => {\n         if (this.player2State === 'attack' && !this.gameOver) {\n           this.player2.play('p2_idle', true);\n           this.player2State = 'idle';\n         }\n       });\n    }\n\n    // Player 2 special (L key or touch)\n    const specialConditionP2 = (\n      this.keys &&\n      this.keys.l && this.keys.l.isDown &&\n      this.player2State !== 'attack' &&\n      this.player2State !== 'special' &&\n      this.attackCount[1] >= 3\n    ) || (this._touchJustPressedP2S && this.player2State !== 'attack' && this.player2State !== 'special' && this.attackCount[1] >= 3);\n    if (specialConditionP2) {\n      this._touchJustPressedP2S = false;\n      this.player2.play('p2_special', true);\n      this.player2State = 'special';\n      tryAttack(this, 1, this.player2, this.player1, now, true);\n      const healthRatio1 = Math.max(0, this.playerHealth[0] / MAX_HEALTH);\n      this.healthBar1.width = 200 * healthRatio1;\n      this.showSpecialEffect(this.player2.x, this.player2.y - 60);\n      this.time.delayedCall(700, () => {\n        if (this.player2State === 'special' && !this.gameOver) {\n          this.player2.play('p2_idle', true);\n          this.player2State = 'idle';\n          // Reset special pips after special is used\n          this.attackCount[1] = 0;\n        }\n      });\n    }\n  }\n\n  updateSceneLayout() {\n    return updateSceneLayout(this);\n  }\n  \n  // --- GAME OVER HANDLER ---\n  endGame(phrase) {\n    if (this.gameOver) return;\n    this.gameOver = true;\n    // Centered winning phrase\n    const winText = this.add.text(\n      this.cameras.main.width / 2,\n      this.cameras.main.height / 2,\n      phrase,\n      {\n        fontSize: Math.max(20, Math.min(36, Math.round(this.cameras.main.width * 0.055))) + 'px',\n        color: '#fff',\n        fontFamily: 'monospace',\n        stroke: '#000',\n        strokeThickness: 8,\n        align: 'center',\n        backgroundColor: 'rgba(0,0,0,0.35)',\n        padding: {\n          left: Math.round(this.cameras.main.width * 0.025),\n          right: Math.round(this.cameras.main.width * 0.025),\n          top: Math.round(this.cameras.main.width * 0.012),\n          bottom: Math.round(this.cameras.main.width * 0.012)\n        }\n      }\n    )\n      .setOrigin(0.5)\n      .setDepth(10001);\n    // Optionally, fade in the text\n    winText.setAlpha(0);\n    this.tweens.add({\n      targets: winText,\n      alpha: 1,\n      duration: 400\n    });\n\n    // --- Add 'Jogar Novamente' button ---\n    const btnY = this.cameras.main.height / 2 + 90;\n    const playAgainBtn = this.add.text(\n      this.cameras.main.width / 2,\n      btnY,\n      'Jogar Novamente',\n      {\n        fontSize: Math.max(18, Math.min(30, Math.round(this.cameras.main.width * 0.045))) + 'px',\n        color: '#fff',\n        backgroundColor: '#44aaff',\n        fontFamily: 'monospace',\n        padding: {\n          left: Math.round(this.cameras.main.width * 0.02),\n          right: Math.round(this.cameras.main.width * 0.02),\n          top: Math.round(this.cameras.main.width * 0.01),\n          bottom: Math.round(this.cameras.main.width * 0.01)\n        },\n        align: 'center',\n        stroke: '#000',\n        strokeThickness: 8,\n        borderRadius: 24\n      }\n    )\n      .setOrigin(0.5)\n      .setDepth(10002)\n      .setAlpha(0)\n      .setInteractive({ useHandCursor: true });\n    this.tweens.add({\n      targets: playAgainBtn,\n      alpha: 1,\n      duration: 400,\n      delay: 200\n    });\n    playAgainBtn.on('pointerdown', () => {\n      winText.destroy();\n      playAgainBtn.destroy();\n      this.scene.restart();\n    });\n    // Winner celebrates, loser lays down\n    if (this.player1 && this.player2) {\n      const p1Dead = this.playerHealth[0] <= 0;\n      const p2Dead = this.playerHealth[1] <= 0;\n      if (p1Dead && !p2Dead) {\n        // Player 2 wins\n        this.player2.setFrame(3); // Winner celebrates\n        this.player2.setFlipX(true);\n        this.player2.setAngle(0);\n        this.player1.setFrame(4); // Loser lays down (frame 4)\n        this.player1.setFlipX(false);\n        this.player1.setAngle(270);\n        this.showSpecialEffect(this.player1.x, this.player1.y);\n      } else if (p2Dead && !p1Dead) {\n        // Player 1 wins\n        this.player1.setFrame(3); // Winner celebrates\n        this.player1.setFlipX(false);\n        this.player1.setAngle(0);\n        this.player2.setFrame(4); // Loser lays down (frame 4)\n        this.player2.setFlipX(true);\n        this.player2.setAngle(270);\n        this.showSpecialEffect(this.player2.x, this.player2.y);\n      } else {\n        // Draw or both dead: both use frame 5\n        this.player1.setFrame(5); // Both use frame 5 for draw\n        this.player1.setFlipX(false);\n        // No rotation for draw\n        this.player2.setFrame(5);\n        this.player2.setFlipX(true);\n        // No rotation for draw\n        this.showSpecialEffect(this.player1.x, this.player1.y);\n        this.showSpecialEffect(this.player2.x, this.player2.y);\n      }\n    }\n    if (this.player1 && this.player1.anims) this.player1.anims.stop();\n    if (this.player2 && this.player2.anims) this.player2.anims.stop();\n\n    // Freeze winner in frame 3 (celebration) after win\n    if (this.player1.frame.name === 3) {\n      this.player1.setFrame(3);\n    }\n    if (this.player2.frame.name === 3) {\n      this.player2.setFrame(3);\n    }\n\n    // Do not remove input listeners; rely on this.gameOver = true to block input after game over.\n    // This avoids breaking keyboard input after scene restart.\n  }\n}\n\n\n\n\n\n\nfunction resizeGame(game) {\n  // Use window.innerWidth/innerHeight for true viewport size (accounts for mobile browser UI)\n  const w = window.innerWidth;\n  const h = window.innerHeight;\n  game.scale.resize(w, h);\n  applyGameCss();\n}\n\n\n// --- Responsive Touch Controls Positioning ---\nKidsFightScene.prototype.updateControlPositions = function() {\n  if (!this.isTouch || !this.touchControls || !this.cameras || !this.cameras.main) return;\n  const cam = this.cameras.main;\n  const w = cam.width;\n  const h = cam.height;\n  // Player 1\n  this.touchControls.p1.left.setPosition(w * 0.08, h * 0.85);\n  this.touchControls.p1.right.setPosition(w * 0.18, h * 0.85);\n  this.touchControls.p1.jump.setPosition(w * 0.13, h * 0.7);\n  this.touchControls.p1.down.setPosition(w * 0.13, h * 0.97);\n  this.touchControls.p1.attack.setPosition(w * 0.28, h * 0.89);\n  this.touchControls.p1.special.setPosition(w * 0.36, h * 0.89);\n  // Player 2\n  this.touchControls.p2.left.setPosition(w * 0.82, h * 0.85);\n  this.touchControls.p2.right.setPosition(w * 0.92, h * 0.85);\n  this.touchControls.p2.jump.setPosition(w * 0.87, h * 0.7);\n  this.touchControls.p2.down.setPosition(w * 0.87, h * 0.97);\n  this.touchControls.p2.attack.setPosition(w * 0.72, h * 0.89);\n  this.touchControls.p2.special.setPosition(w * 0.64, h * 0.89);\n  // Labels (order must match creation)\n  if (this.touchLabels && this.touchLabels.length === 12) {\n    this.touchLabels[0].setPosition(w * 0.06, h * 0.83);\n    this.touchLabels[1].setPosition(w * 0.16, h * 0.83);\n    this.touchLabels[2].setPosition(w * 0.11, h * 0.68);\n    this.touchLabels[3].setPosition(w * 0.11, h * 0.95);\n    this.touchLabels[4].setPosition(w * 0.25, h * 0.87);\n    this.touchLabels[5].setPosition(w * 0.33, h * 0.87);\n    this.touchLabels[6].setPosition(w * 0.79, h * 0.83);\n    this.touchLabels[7].setPosition(w * 0.89, h * 0.83);\n    this.touchLabels[8].setPosition(w * 0.84, h * 0.68);\n    this.touchLabels[9].setPosition(w * 0.84, h * 0.95);\n    this.touchLabels[10].setPosition(w * 0.69, h * 0.87);\n    this.touchLabels[11].setPosition(w * 0.61, h * 0.87);\n  }\n}\n\n// Phaser Game Config (must be after KidsFightScene is defined)\nconst config = {\n  type: Phaser.AUTO,\n  width: GAME_WIDTH,\n  height: GAME_HEIGHT,\n  backgroundColor: '#222',\n  parent: 'game-container',\n  scene: KidsFightScene,\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: GRAVITY },\n      debug: false\n    }\n  },\n  scale: {\n    mode: Phaser.Scale.RESIZE,\n    autoCenter: Phaser.Scale.CENTER_BOTH\n  }\n};\n\nwindow.onload = () => {\n  // Set initial size to fit screen\n  config.width = window.innerWidth;\n  config.height = window.innerHeight;\n  config.scale.width = window.innerWidth;\n  config.scale.height = window.innerHeight;\n  const game = new Phaser.Game(config);\n  // Initial resize to account for mobile browser UI\n  resizeGame(game);\n\n  // Helper: double-resize to fix mobile browser chrome issues\n  function resizeWithDelay() {\n    resizeGame(game);\n    setTimeout(() => resizeGame(game), 250); // Second resize after browser chrome settles\n  }\n\n  window.addEventListener('resize', resizeWithDelay);\n  window.addEventListener('orientationchange', resizeWithDelay);\n}\n","module.exports = __parcel__import__.meta.resolve(\"2ZnZY\");","module.exports = __parcel__import__.meta.resolve(\"foXlV\");","module.exports = __parcel__import__.meta.resolve(\"9MvWO\");","// Pure game logic utilities for KidsFightScene\n\n// Layout update logic for scene objects\nfunction updateSceneLayout(scene) {\n  const w = scene.scale.width;\n  const h = scene.scale.height;\n  // Background\n  if (scene.children && scene.children.list) {\n    const bg = scene.children.list.find(obj => obj.texture && obj.texture.key === 'scenario1');\n    if (bg) {\n      bg.setPosition(w / 2, h / 2);\n      bg.displayWidth = w;\n      bg.displayHeight = h;\n    }\n  }\n  // Platform\n  if (scene.children && scene.children.list) {\n    const platformRect = scene.children.list.find(obj => obj.type === 'Rectangle' && obj.fillColor === 0x8B5A2B);\n    if (platformRect) {\n      platformRect.setPosition(w / 2, 230 + 20 / 2);\n      platformRect.displayWidth = w;\n    }\n  }\n  // Camera and world bounds\n  if (scene.cameras && scene.cameras.main && scene.physics && scene.physics.world) {\n    scene.cameras.main.setBounds(0, 0, w, h);\n    scene.physics.world.setBounds(0, 0, w, h);\n  }\n  // Touch controls\n  if (typeof scene.updateControlPositions === 'function') {\n    scene.updateControlPositions();\n  }\n  // Health bars\n  if (scene.healthBar1 && scene.healthBar2 && scene.healthBar1Border && scene.healthBar2Border) {\n    // Bar width: 25% of screen width, height: 5% of height\n    const barWidth = w * 0.25;\n    const barHeight = h * 0.05;\n    const barY = h * 0.07;\n    const bar1X = w * 0.25;\n    const bar2X = w * 0.75;\n    scene.healthBar1Border.setPosition(bar1X, barY).setSize(barWidth + 4, barHeight + 4);\n    scene.healthBar2Border.setPosition(bar2X, barY).setSize(barWidth + 4, barHeight + 4);\n    scene.healthBar1.setPosition(bar1X, barY).setSize(barWidth, barHeight);\n    scene.healthBar2.setPosition(bar2X, barY).setSize(barWidth, barHeight);\n  }\n  // Special pips (3 per player) - match main.js create()\n  if (scene.specialPips1 && scene.specialPips2) {\n    const barY = h * 0.07;\n    const pipY = barY - h * 0.035; // slightly above health bar\n    const pipR = Math.max(10, h * 0.018); // match create()\n    // Player 1: left, spaced 30px apart at 800px width\n    for (let i = 0; i < 3; i++) {\n      const pip1X = w * 0.25 - pipR * 3 + i * pipR * 3;\n      if (scene.specialPips1[i]) scene.specialPips1[i].setPosition(pip1X, pipY).setRadius(pipR);\n    }\n    // Player 2: right, spaced 30px apart at 800px width\n    for (let i = 0; i < 3; i++) {\n      const pip2X = w * 0.75 - pipR * 3 + i * pipR * 3;\n      if (scene.specialPips2[i]) scene.specialPips2[i].setPosition(pip2X, pipY).setRadius(pipR);\n    }\n  }\n  // Special ready circles (big S) - match main.js create()\n  if (scene.specialReady1 && scene.specialReadyText1) {\n    const r = Math.max(20, h * 0.045);\n    const x = w * 0.25;\n    const y = h * 0.13;\n    scene.specialReady1.setPosition(x, y).setRadius(r);\n    scene.specialReadyText1.setPosition(x, y);\n  }\n  if (scene.specialReady2 && scene.specialReadyText2) {\n    const r = Math.max(20, h * 0.045);\n    const x = w * 0.75;\n    const y = h * 0.13;\n    scene.specialReady2.setPosition(x, y).setRadius(r);\n    scene.specialReadyText2.setPosition(x, y);\n  }\n  // Timer text\n  if (scene.timerText) {\n    // Font size: min 32px, but scale up for large screens (e.g. 4vw)\n    const fontSize = Math.max(32, Math.round(w * 0.045));\n    scene.timerText.setFontSize(fontSize + 'px');\n    scene.timerText.setPosition(w / 2, h * 0.11);\n  }\n}\n\n// CSS application logic for game canvas and parent\nfunction applyGameCss() {\n  const canvas = document.querySelector('canvas');\n  const parent = document.getElementById('game-container');\n  if (canvas) {\n    canvas.style.position = 'fixed';\n    canvas.style.left = 'env(safe-area-inset-left, 0px)';\n    canvas.style.top = 'env(safe-area-inset-top, 0px)';\n    canvas.style.width = 'calc(100vw - env(safe-area-inset-left, 0px) - env(safe-area-inset-right, 0px))';\n    canvas.style.height = 'calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px))';\n    canvas.style.maxWidth = '100vw';\n    canvas.style.maxHeight = '100vh';\n    canvas.style.objectFit = 'contain';\n    canvas.style.background = '#222';\n  }\n  if (parent) {\n    parent.style.position = 'fixed';\n    parent.style.left = 'env(safe-area-inset-left, 0px)';\n    parent.style.top = 'env(safe-area-inset-top, 0px)';\n    parent.style.width = '100vw';\n    parent.style.height = '100vh';\n    parent.style.background = '#222';\n    parent.style.overflow = 'hidden';\n  }\n}\n\n// tryAttack logic (simplified for testability)\nfunction tryAttack(scene, playerIdx, attacker, defender, now, special) {\n  // Robustly determine defenderIdx\n  let defenderIdx = undefined;\n  if (defender === scene.player1) defenderIdx = 0;\n  else if (defender === scene.player2) defenderIdx = 1;\n  else {\n    console.error('[TRYATTACK] Could not determine defenderIdx!', defender, scene.player1, scene.player2);\n    return;\n  }\n  console.log('[TRYATTACK] defenderIdx:', defenderIdx, 'playerHealth before:', scene.playerHealth[defenderIdx]);\n  if (!attacker || !defender) return;\n  const ATTACK_RANGE = 180;\n  const ATTACK_COOLDOWN = 500;\n  if (!scene.lastAttackTime) scene.lastAttackTime = [0, 0];\n  if (!scene.attackCount) scene.attackCount = [0, 0];\n  if (now - scene.lastAttackTime[playerIdx] < ATTACK_COOLDOWN) {\n    // console.log('[DEBUG] tryAttack: Attack on cooldown for player', playerIdx);\n    return;\n  }\n  if (Math.abs(attacker.x - defender.x) > ATTACK_RANGE) {\n    // console.log('[DEBUG] tryAttack: Out of range. Attacker x:', attacker.x, 'Defender x:', defender.x);\n    return;\n  }\n  scene.lastAttackTime[playerIdx] = now;\n  scene.attackCount[playerIdx]++;\n  scene.playerHealth[defenderIdx] = (typeof scene.playerHealth[defenderIdx] === 'number' ? scene.playerHealth[defenderIdx] : 100) - (special ? 30 : 10);\n  console.log('[TRYATTACK] playerHealth after:', scene.playerHealth[defenderIdx]);\n  if (scene.cameras && scene.cameras.main && typeof scene.cameras.main.shake === 'function') {\n    scene.cameras.main.shake(special ? 250 : 100, special ? 0.03 : 0.01);\n  }\n}\n\nexport { updateSceneLayout, applyGameCss, tryAttack };\n"],"names":["$parcel$interopDefault","a","__esModule","default","$703cd0b7f1a80901$exports","resolve","$29dc1bd428d227fa$exports","$4d44d7ac7a91b6cd$exports","$4244f6a75d6df63d$export$36c7bbefcce976d2","canvas","document","querySelector","parent","getElementById","style","position","left","top","width","height","maxWidth","maxHeight","objectFit","background","overflow","$4244f6a75d6df63d$export$d918436b04969c89","scene","playerIdx","attacker","defender","now","special","defenderIdx","player1","player2","console","error","log","playerHealth","lastAttackTime","attackCount","Math","abs","x","cameras","main","shake","$efd3ba4ec2608b1d$var$GAME_WIDTH","window","innerWidth","$efd3ba4ec2608b1d$var$GAME_HEIGHT","innerHeight","$efd3ba4ec2608b1d$var$KidsFightScene","Phaser","Scene","showSpecialEffect","y","count","specialEffect","clear","setVisible","setAlpha","setScale","lineStyle","strokeCircle","tweens","add","targets","alpha","scaleX","scaleY","duration","onComplete","constructor","lungeTimer","timeLeft","player1State","player2State","init","data","selected","p1","p2","preload","load","image","create","gameOver","textures","exists","frameWidths","player1Texture","get","getSourceImage","addSpriteSheet","frameWidth","frameHeight","startFrame","endFrame","tex","frames","__BASE","i","length","frameWidths2","player2Texture","tex2","x2","bg","setOrigin","displayWidth","displayHeight","cam","isTouch","padX","padY","physics","world","setBounds","touchControls","navigator","maxTouchPoints","rectangle","setInteractive","setDepth","right","jump","down","attack","circle","touchFlags","setupBtn","btn","flagObj","flag","on","Object","entries","forEach","k","touchLabels","push","text","fontSize","color","updateControlPositions","hitFlash","graphics","scale","PLATFORM_Y","PLATFORM_HEIGHT","platform","staticGroup","setDisplaySize","refreshBody","playerSpritesSafe","selectedSafe","p1Key","p2Key","p1X","p2X","playerY","sprite","body","setSize","setOffset","collider","setCollideWorldBounds","setBounce","facing","setFlipX","anims","key","frame","frameRate","repeat","play","angle","_originalY","floatPlatform","cursors","input","keyboard","createCursorKeys","keys","addKeys","d","w","v","b","n","s","l","semicolon","isDown","addEventListener","e","healthBar1Border","healthBar2Border","setStrokeStyle","healthBar1","healthBar2","children","bringToTop","specialPips1","pip","specialPips2","setFillStyle","specialReady1","specialReadyText1","specialReady2","specialReadyText2","fontFamily","fontStyle","timerText","ceil","align","stroke","strokeThickness","$efd3ba4ec2608b1d$var$resizeGame","game","updateSceneLayout","update","time","delta","updateSpecialPips","pips","specialReady","specialReadyText","_touchWasDownP1A","_touchJustPressedP1A","_touchWasDownP1S","_touchJustPressedP1S","_touchWasDownP2A","_touchJustPressedP2A","_touchWasDownP2S","_touchJustPressedP2S","up","lastTimerUpdate","isNaN","timerElapsed","floor","max","setText","endGame","p1Moving","setVelocityX","onFloor","setVelocityY","currentAnim","p2Moving","healthRatio","delayedCall","healthRatio1","h","list","find","obj","texture","setPosition","platformRect","type","fillColor","barWidth","barHeight","barY","bar1X","bar2X","pipY","pipR","pip1X","setRadius","pip2X","r","round","setFontSize","phrase","winText","min","backgroundColor","padding","bottom","btnY","playAgainBtn","borderRadius","useHandCursor","delay","destroy","restart","p1Dead","p2Dead","setFrame","setAngle","stop","name","resize","prototype","$efd3ba4ec2608b1d$var$config","AUTO","arcade","gravity","debug","mode","Scale","RESIZE","autoCenter","CENTER_BOTH","onload","Game","resizeWithDelay","setTimeout"],"version":3,"file":"kidsfight.81e35bcd.js.map"}